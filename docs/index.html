<html><head><style>body {
   color: black;
}
</style></head><body><h1 id="coding-creed-origins">coding-creed-origins</h1>
<h2 id="hello-there-">Hello there!</h2>
<p>Thank you for visiting! Feel free to see the codes. But it would be nice if you try the problems yourself first :) 
And I would really like to know who you are. Perhaps you could <code>Star</code> the repo :)
Thank you for reading.</p>
<h3 id="reminder">Reminder</h3>
<p><a href="https://github.com/fahimfarhan/Windows-10-blue">Linux custom theme</a> Next time when you(future me) reinstall linux, download this customized theme and save time :3</p>
<h2 id="modular-inverse">Modular Inverse</h2>
<p><a href="https://planetcalc.com/3311/">online calculator</a>, <a href="https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/">geeksforgeeks</a>, <a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/modular-inverses">khanacademy</a></p>
<h2 id="useful-links-blogs">Useful Links/Blogs</h2>
<ul>
<li><a href="https://github.com/tayllan/awesome-algorithms">tayllan/awesome-algorithms</a></li>
<li><a href="https://visualgo.net/en">ds &amp; algo visualization</a></li>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">ds &amp; algo visualization 2</a></li>
<li><a href="http://yufeizhao.com/olympiad/">yufeizhao.com/olympiad</a></li>
<li><a href="https://www.quora.com/What-important-topics-of-number-theory-should-every-programmer-know">What important topics of number theory should every programmer know?</a></li>
<li><a href="https://www.quora.com/How-do-I-prepare-for-Google-Code-Jam-in-2018">How do I prepare for Google Code Jam in 2018?</a></li>
<li><a href="http://codeforces.com/blog/entry/18051">Segment Tree Example Code Demo</a></li>
<li><a href="https://codeforces.com/blog/entry/15890">Dark Knight Segment Tree</a></li>
<li><a href="https://codeforces.com/blog/entry/15729">Dark Knight DS</a></li>
</ul>
<h2 id="important-repos">Important Repos</h2>
<ul>
<li><a href="https://github.com/ruippeixotog/google-code-jam-2017">google-code-jam-2017-solns</a></li>
<li><a href="https://github.com/AnikSarker/DeobureoMinkyuParty">AnikSarker/DeobureoMinkyuParty</a></li>
<li><a href="https://github.com/AnikSarker/ACM-ICPC-Live-Archive-Solutions">AnikSarker/ACM-ICPC-Live-Archive-Solutions</a></li>
<li><a href="https://github.com/AnikSarker/UVA-Online-Judge-solutions">AnikSarker/UVA-Online-Judge-solutions</a></li>
<li><a href="https://github.com/Diusrex/UVA-Solutions">Diusrex/UVA-Solutions</a></li>
<li><a href="https://github.com/ahsantarique/Contest-Programming-Codes">ahsantarique/Contest-Programming-Codes</a></li>
<li><a href="https://github.com/Ayesha049/all-contest-code">Ayesha049/all-contest-code</a></li>
<li><a href="https://github.com/tasneemria/Codeforces_Solved">tasneemria/Codeforces_Solved</a></li>
<li><a href="https://github.com/Salsabil007/programming">Salsabil007/programming</a></li>
<li><a href="https://github.com/islamazhar/CodeForces">islamazhar/CodeForces</a></li>
<li><a href="https://github.com/shahidul2k9/problem-solution">shahidul2k9/problem-solution</a> </li>
<li><a href="https://github.com/jwasham/coding-interview-university">jwasham/coding-interview-university</a> </li>
<li><a href="https://github.com/hasancse91/Programming-Problem-In-Bengali">hasancse91/Programming-Problem-In-Bengali</a> </li>
<li><a href="https://github.com/me-shaon/bangla-programming-resources">me-shaon/bangla-programming-resources</a> </li>
<li><a href="https://www.codechef.com/getting-started">codechef.com/getting-started</a></li>
<li><a href="https://github.com/morris821028/UVa">morris821028/UVa</a><h4 id="codejam">codejam</h4>
</li>
<li><a href="https://github.com/hickford/codejam">hickford/codejam</a></li>
<li><a href="https://github.com/ruippeixotog/google-code-jam-2018">ruippeixotog/google-code-jam-2018</a><h4 id="spoj">spoj</h4>
</li>
<li><a href="https://github.com/spojsolutions/spoj">spojsolutions/spoj</a></li>
<li><a href="https://github.com/bnslakki/Spoj">bnslakki/Spoj</a></li>
</ul>
<h3 id="ml">ML</h3>
<ul>
<li><a href="https://madewithml.com/topics/">madewithhtml</a></li>
</ul>
<h2 id="algorithms">ALGORITHMS</h2>
<ol>
<li><ul>
<li>[ ] study GeeksForGeeks, notebook.pdf</li>
</ul>
</li>
<li><ul>
<li>[x] Basic data sturctures (arrays, queues, linked lists, etc.).</li>
</ul>
</li>
<li><ul>
<li>[ ]  Bit manipulation.</li>
</ul>
</li>
<li><ul>
<li>[ ]  Advanced data structures:</li>
</ul>
</li>
<li>[ ]  a. Union-Find Disjoint Sets.</li>
<li>[x]  b. Segment Tree.</li>
<li>[x]  c. Binary Indexed Tree (a.k.a Fenwik Tree).</li>
<li>[x] d. Graph.</li>
<li>[ ]  e. Treap.</li>
<li>[ ]  f. Skip Lists.</li>
<li>[ ]  e. Some self balanced Binary Search trees (e.g. Red Black Trees).</li>
<li><ul>
<li>[ ]  Brute force and it&#39;s tricks and advanced techniques (such as, pruning, bitmasks, meet in the middle, iterative deepining etc.)</li>
</ul>
</li>
<li><ul>
<li>[ ]  Binary Search (not only the basic code).</li>
</ul>
</li>
<li><ul>
<li>[x] Greedy.</li>
</ul>
</li>
<li><ul>
<li>[ ]  Dynamic programming and it&#39;s tricks and optimisations (Knuth optimisation, convex hull optimisation, bitmasks, etc.).</li>
</ul>
</li>
<li><ul>
<li>[ ]  Graph algorithms:</li>
</ul>
</li>
<li>[x] a. Traversal (DFS &amp; BFS) algorithms and how to use them.</li>
<li>[x] b. Finding Connected Components.</li>
<li>[x] c. Flood Fill.</li>
<li>[x] d. Topological Sorting (the famous algorithm uses DFS but you should also know Kahn&#39;s algorithm that uses BFS as it has much applications). </li>
<li>[x] e. Bipartite Check.</li>
<li>[x] f. Kruskal&#39;s and Prim&#39;s algorithms for finding the Minimum Spanning Tree of a graph and the variants of the problem.</li>
<li>[x] g. Dijkstra&#39;s algorithm for solving the Single Source Shortest Path (SSSP) Problem with out negaitive cycles.</li>
<li>[x] h. Bellman-Ford&#39;s algorithm for solving the SSSP problem with negative sycles.</li>
<li>[x] i. Floyd-Warshall&#39;s algorithm for solving the All Pairs Shortest Path (APSP) problem and it&#39;s variants.</li>
<li>[ ] j. Network Flow problem (all it&#39;s algorithms, variants and the problems reducable to it).</li>
<li><p>[x] k. Finding Strongly Connected Components.</p>
</li>
<li><ul>
<li>[ ]  Mathematics:</li>
</ul>
</li>
<li>[ ] a. You should be familiar with the BigInteger class in Java (maybe write your own if you are in love with C++).</li>
<li>[ ] b. Some Combinatorics.</li>
<li>[ ] c. Number Theory (all what you can learn about it).</li>
<li>[ ] d. Probability Theory.</li>
<li>[x] e. Floyd-Cycle detection algorithm.</li>
<li>[ ] f. Game Theory (especially impartial games and Sprague-Grundy Theorem).</li>
<li><ul>
<li>[ ]  Strings:</li>
</ul>
</li>
<li>[x] a. Basic Manipulation.</li>
<li>[x] b. Z-Algorithm for finding a pattern in a text.</li>
<li>[ ] c. Knuth-Morris-Pratt Algorithm for finding a pattern in a text.</li>
<li>[ ] d. Hashing and Rabin-Karp Algorithm for finding a pattern in a text.</li>
<li>[ ] e. Trie data structure.</li>
<li>[ ] f. Aho-Corasick Algorithm for finding multiple patterns in a text.</li>
<li>[ ] g. Suffix Array data structure.</li>
<li>[ ] h. Suffix Automaton data structure.</li>
<li><ul>
<li>[ ]  Computational Geometry Algorithms.</li>
</ul>
</li>
<li><p>-[ ] <a href="https://www.geeksforgeeks.org/category/project/">https://www.geeksforgeeks.org/category/project/</a></p>
</li>
</ol>
<h2 id="todolist">ToDoList</h2>
<p>Linux from scratch 
Machine Learning
Deep Learning 
CodeForces
Qt/C++
OpenCV
TensonFlow
Keras
Spring
Vue.js
kali linux
Projects from Freelancer
CodinGame, Halit AI projects
Kaggle ML projects
create a messenger in webapp!
Learn GDB, Valgrind</p>
<h2 id="cool-tools">Cool Tools</h2>
<ul>
<li>BundlePhobia <a href="https://bundlephobia.com/">https://bundlephobia.com/</a></li>
<li>CloudCraft <a href="https://cloudcraft.co/">https://cloudcraft.co/</a></li>
<li>Figma <a href="https://www.figma.com">https://www.figma.com</a></li>
<li>Fontflipper <a href="https://fontflipper.com/">https://fontflipper.com/</a></li>
<li>Visbug <a href="https://github.com/GoogleChromeLabs/ProjectVisBug">https://github.com/GoogleChromeLabs/ProjectVisBug</a></li>
<li>Insomnia <a href="https://insomnia.rest/">https://insomnia.rest/</a></li>
<li>Flare <a href="https://www.2dimensions.com/about-flare">https://www.2dimensions.com/about-flare</a></li>
</ul>
<h2 id="cool-stuffs">Cool Stuffs</h2>
<pre><code>    int a[<span class="hljs-number">100</span>] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// shorter way to initialize in cpp. yeah, I didn't know that</span>
</code></pre><pre><code>next_permutation(<span class="hljs-name">v</span>.begin(), v.end())<span class="hljs-comment">;</span>
</code></pre><pre><code>regex_match(<span class="hljs-name">s</span>,regex(<span class="hljs-string">"(1|14|144)*"</span>))<span class="hljs-comment">;</span>
</code></pre><pre><code><span class="hljs-symbol">std</span>::<span class="hljs-keyword">string </span><span class="hljs-meta">data</span> = <span class="hljs-string">"Abc"</span><span class="hljs-comment">;</span>
<span class="hljs-symbol">std</span>::transform(<span class="hljs-meta">data</span>.<span class="hljs-keyword">begin(), </span><span class="hljs-meta">data</span><span class="hljs-meta">.end</span>(), <span class="hljs-meta">data</span>.<span class="hljs-keyword">begin(), </span>::tolower)<span class="hljs-comment">;</span>
</code></pre><pre><code><span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::size_type i = <span class="hljs-number">0</span>; i &lt; str.length(); ++i)
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">tolower</span>(str[i], loc);
</code></pre><h3 id="uva-style-input-">UVA style input...</h3>
<pre><code><span class="hljs-keyword">while</span>(getline(cin, s[<span class="hljs-keyword">line</span>])){
            <span class="hljs-keyword">if</span>(s[<span class="hljs-keyword">line</span>].<span class="hljs-built_in">length</span>()&gt;longest){
                longest = s[<span class="hljs-keyword">line</span>].<span class="hljs-built_in">length</span>();
            }
            <span class="hljs-keyword">line</span>++;
        }
</code></pre><h3 id="crazy-input-format">Crazy Input Format</h3>
<pre><code>int main(){     
  int A[] = gets(stdin);
}
<span class="hljs-comment">// input.txt</span>
{<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>}
</code></pre><h3 id="search-for-smallest-element-s-index-in-an-array-in-range-l-r-">search for smallest element&#39;s index in an array in range[l,r]</h3>
<pre><code><span class="hljs-attribute">int m</span>=min_element(a+l,a+r+1)-a;
</code></pre><h3 id="mod-forluma">Mod forluma</h3>
<pre><code>b_i = <span class="hljs-comment">(a_i + x)</span><span class="hljs-meta">%</span>m  &lt;=&gt;  x = <span class="hljs-comment">(b_i - a_i + m)</span><span class="hljs-meta">%</span>m
</code></pre><h3 id="cpp-stl-multiset">Cpp stl Multiset</h3>
<p>You can do this: </p>
<pre><code>multiset&lt;int&gt; <span class="hljs-built_in">set</span>A, <span class="hljs-built_in">set</span>B; 
/*... some code*/;
<span class="hljs-keyword">if</span>(<span class="hljs-built_in">set</span>A == <span class="hljs-built_in">set</span>B)
{  /*todo logic*/  } // <span class="hljs-keyword">if</span> they are equal, <span class="hljs-keyword">do</span> sth, <span class="hljs-keyword">else</span> <span class="hljs-keyword">do</span> other thing...
</code></pre><h1 id="-acm-icpc-cheat-sheet">   ACM-ICPC Cheat Sheet</h1>
<pre><code><span class="hljs-keyword">Orange </span><span class="hljs-keyword">Juice </span>情報
</code></pre><p><img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f388.png?v5" alt="balloon">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f388.png?v5" alt="balloon">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f388.png?v5" alt="balloon">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f388.png?v5" alt="balloon">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f388.png?v5" alt="balloon">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f388.png?v5" alt="balloon">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f388.png?v5" alt="balloon">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f388.png?v5" alt="balloon">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f388.png?v5" alt="balloon">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f388.png?v5" alt="balloon"></p>
<p><img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f364.png?v5" alt="fried_shrimp">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f363.png?v5" alt="sushi">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f365.png?v5" alt="fish_cake">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f359.png?v5" alt="rice_ball">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f358.png?v5" alt="rice_cracker">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f372.png?v5" alt="stew">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f362.png?v5" alt="oden">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f354.png?v5" alt="hamburger">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f369.png?v5" alt="doughnut">
<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f36a.png?v5" alt="cookie"></p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p>
<ul>
<li><a href="#1-basic">1. Basic</a><ul>
<li><a href="#11-c-solution-template">1.1 C++ Solution Template</a><ul>
<li><a href="#111-optional-include-list">1.1.1 Optional include list</a></li>
</ul>
</li>
<li><a href="#12-strings">1.2 Strings</a><ul>
<li><a href="#121-c-string">1.2.1 C++ String</a><ul>
<li><a href="#read-one-line">read one line</a></li>
<li><a href="#convert-to-char-array">Convert to char array</a></li>
</ul>
</li>
<li><a href="#122-c-string-character-array">1.2.2 C String (Character Array)</a><ul>
<li><a href="#input-c-string">Input C String</a></li>
<li><a href="#convert-to-c-string">Convert to C++ string</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#13-stl-algorithm">1.3 STL Algorithm</a><ul>
<li><a href="#131-permutation">1.3.1 Permutation</a></li>
<li><a href="#132-binary-search">1.3.2 Binary Search</a></li>
<li><a href="#133-lower-bound">1.3.3 Lower Bound</a></li>
<li><a href="#134-swap">1.3.4 Swap</a></li>
<li><a href="#135-heap">1.3.5 Heap</a></li>
<li><a href="#136-sort">1.3.6 Sort</a></li>
<li><a href="#137-compare">1.3.7 Compare</a><ul>
<li><a href="#using-lambda-expression">Using lambda expression</a></li>
<li><a href="#compare-function">Compare function</a></li>
<li><a href="#define-operator-">Define operator &lt;()</a></li>
<li><a href="#define-operator">Define operator()()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#14-stl-containers">1.4 STL Containers</a><ul>
<li><a href="#141-map">1.4.1 Map</a><ul>
<li><a href="#define-a-map">Define a Map</a></li>
<li><a href="#commonly-used-method">Commonly used method</a></li>
<li><a href="#red-black-tree">Red-black Tree</a></li>
<li><a href="#hash-map-unordered-map">Hash Map (Unordered Map)</a></li>
<li><a href="#commonly-used-method-1">Commonly used method</a></li>
</ul>
</li>
<li><a href="#142-pair">1.4.2 Pair</a></li>
<li><a href="#143-vector">1.4.3 Vector</a><ul>
<li><a href="#constructor">Constructor</a></li>
<li><a href="#methods">Methods</a></li>
</ul>
</li>
<li><a href="#144-list">1.4.4 List</a><ul>
<li><a href="#methods-1">Methods</a></li>
</ul>
</li>
<li><a href="#145-queue">1.4.5 Queue</a></li>
<li><a href="#146-double-ended-queue">1.4.6 Double-ended Queue</a></li>
<li><a href="#147-stack">1.4.7 Stack</a></li>
<li><a href="#148-priority-queue">1.4.8 Priority Queue</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-advanced-data-structures">2. Advanced Data Structures</a><ul>
<li><a href="#21-heap">2.1 Heap</a></li>
<li><a href="#22-tree">2.2 Tree</a><ul>
<li><a href="#220-tree-traversal">2.2.0 Tree Traversal</a></li>
<li><a href="#221-pointer-jumping">2.2.1 Pointer Jumping</a></li>
<li><a href="#222-heavy-light-decomposition">2.2.2 Heavy-Light Decomposition</a></li>
<li><a href="#223-lowest-common-ancestor">2.2.3 Lowest Common Ancestor</a><ul>
<li><a href="#2231-tarjans-off-line-algorithm">2.2.3.1 Tarjan&#39;s Off-line Algorithm</a></li>
</ul>
</li>
<li><a href="#224-centroid-decomposition">2.2.4 Centroid Decomposition</a></li>
</ul>
</li>
<li><a href="#23-trie--trie-graph--ac-automaton">2.3 Trie / Trie Graph / AC Automaton</a></li>
<li><a href="#24-suffix-tree">2.4 Suffix Tree</a></li>
<li><a href="#25-suffix-array">2.5 Suffix Array</a><ul>
<li><a href="#251-build-suffix-array">2.5.1 Build Suffix Array</a></li>
<li><a href="#252-pattern-matching">2.5.2 Pattern Matching</a></li>
<li><a href="#253-longest-common-prefix">2.5.3 Longest Common Prefix</a></li>
<li><a href="#254-longest-repeated-substring">2.5.4 Longest Repeated Substring</a></li>
<li><a href="#255-longest-common-substring">2.5.5 Longest Common Substring</a></li>
</ul>
</li>
<li><a href="#26-binary-indexed-tree">2.6 Binary Indexed Tree</a></li>
<li><a href="#27-segment-tree">2.7 Segment Tree</a><ul>
<li><a href="#270-range-update--range-query">2.7.0 Range Update + Range Query</a></li>
<li><a href="#271-color">2.7.1 Color</a></li>
<li><a href="#272-range-sum--range-replace">2.7.2 Range Sum + Range Replace</a></li>
</ul>
</li>
<li><a href="#28-range-minimum-query-rmq">2.8 Range Minimum Query RMQ</a></li>
<li><a href="#29-union-find-set">2.9 Union-find Set</a><ul>
<li><a href="#291-union-find-set---application">2.9.1 Union-find Set - application</a></li>
</ul>
</li>
<li><a href="#210-bloom-filter--similar">2.10 Bloom Filter (?) (Similar)</a></li>
</ul>
</li>
<li><a href="#3-methodology">3. Methodology</a><ul>
<li><a href="#30-greedy">3.0 Greedy</a></li>
<li><a href="#31-recursive">3.1 Recursive</a><ul>
<li><a href="#311-hanoi">3.1.1 Hanoi</a></li>
</ul>
</li>
<li><a href="#32-dynamic-programming">3.2 Dynamic Programming</a><ul>
<li><a href="#321-longest-increasing-subsequence-lis">3.2.1 Longest Increasing Subsequence (LIS)</a></li>
</ul>
</li>
<li><a href="#33-divide-and-conquer">3.3 Divide and Conquer</a><ul>
<li><a href="#331-binary-search">3.3.1 binary search</a></li>
</ul>
</li>
<li><a href="#34-search">3.4 Search</a><ul>
<li><a href="#342-%E5%8F%8C%E5%90%91-bfs">3.4.2 双向 BFS</a></li>
<li><a href="#343-%E4%BB%8E%E7%BB%88%E7%82%B9%E5%BC%80%E5%A7%8B%E6%90%9C">3.4.3 从终点开始搜</a></li>
<li><a href="#344-%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E6%90%9C%E7%B4%A2-binary-increasedecrease">3.4.4 迭代加深搜索 (binary increase/decrease)</a></li>
</ul>
</li>
<li><a href="#35-brute-force">3.5 Brute Force</a><ul>
<li><a href="#351-%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90">3.5.1 子集生成</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-string">4. String</a><ul>
<li><a href="#41-kmp">4.1 KMP</a></li>
<li><a href="#42-boyer-moore">4.2 Boyer-Moore</a></li>
<li><a href="#43-longest-palindromic-substring-manachers-algorithm">4.3 Longest palindromic substring (Manacher&#39;s algorithm)</a></li>
</ul>
</li>
<li><a href="#5-graph">5. Graph</a><ul>
<li><a href="#51-graph-structure">5.1 Graph Structure</a></li>
<li><a href="#52-minimium-spanning-tree">5.2 Minimium Spanning Tree</a><ul>
<li><a href="#521-prims">5.2.1 Prim&#39;s</a></li>
<li><a href="#522-kruskal">5.2.2 Kruskal</a></li>
</ul>
</li>
<li><a href="#53-shortest-path">5.3 Shortest Path</a><ul>
<li><a href="#531-%E4%BB%BB%E6%84%8F%E4%B8%A4%E7%82%B9">5.3.1 任意两点</a></li>
<li><a href="#532-bellman%E2%80%93ford">5.3.2 Bellman–Ford</a></li>
<li><a href="#533-spfa">5.3.3 SPFA</a></li>
<li><a href="#534-dijkstra">5.3.4 Dijkstra</a></li>
</ul>
</li>
<li><a href="#54-maximum-matching">5.4 Maximum Matching</a><ul>
<li><a href="#541-on-bipartite-graph-%E4%BA%8C%E5%88%86%E5%9B%BE">5.4.1 on Bipartite Graph 二分图</a><ul>
<li><a href="#5411-hungarian-algorithm-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95">5.4.1.1 Hungarian algorithm 匈牙利算法</a></li>
<li><a href="#5412-hopcroft%E2%80%93karp-algorithm">5.4.1.2 Hopcroft–Karp Algorithm</a></li>
</ul>
</li>
<li><a href="#542-on-general-graph">5.4.2 on General Graph</a><ul>
<li><a href="#5421-blossom-algorithm">5.4.2.1 Blossom Algorithm</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#55-maximum-flow-problem-%E6%9C%80%E5%A4%A7%E6%B5%81">5.5 Maximum Flow Problem 最大流</a><ul>
<li><a href="#551-dinic">5.5.1 Dinic</a></li>
<li><a href="#552-improved-sap--gap-optimization">5.5.2 Improved SAP + Gap Optimization</a></li>
<li><a href="#553-minimum-cost-maximum-flow">5.5.3 Minimum-Cost Maximum-Flow</a></li>
<li><a href="#554-more-applications-and-properties">5.5.4 More Applications and Properties</a></li>
</ul>
</li>
<li><a href="#56-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-%E5%9B%BE%E7%9A%84-%E5%89%B2%E7%82%B9-%E6%A1%A5-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E6%94%AF">5.6 强连通分量 图的 割点, 桥, 双连通分支</a></li>
<li><a href="#57-topological-sort--%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">5.7 Topological Sort / 拓扑排序</a></li>
<li><a href="#58-euler-cyclepath-hamilton-cyclepath">5.8 Euler Cycle/Path, Hamilton Cycle/Path</a></li>
<li><a href="#59-find-negative-weight-cycle-on-a-graph">5.9 find negative (weight) Cycle on a graph</a></li>
</ul>
</li>
<li><a href="#6-number--mathematics">6. Number + Mathematics</a><ul>
<li><a href="#61-biginteger--bigdecimal">6.1 BigInteger + BigDecimal</a><ul>
<li><a href="#611-c-big-integer">6.1.1 C++ Big Integer</a></li>
<li><a href="#612-the-java-approach">6.1.2 The Java Approach</a></li>
</ul>
</li>
<li><a href="#62-matrix">6.2 Matrix</a></li>
<li><a href="#63-number-theory">6.3 Number Theory</a><ul>
<li><a href="#631-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0-">6.3.1 欧拉函数 ?</a></li>
<li><a href="#632-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95--gcd">6.3.2 欧几里得算法 / gcd</a></li>
<li><a href="#633-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">6.3.3 扩展欧几里得算法</a></li>
<li><a href="#634-%E6%B1%82%E8%A7%A3%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B">6.3.4 求解不定方程</a></li>
<li><a href="#635-%E6%B1%82%E8%A7%A3%E6%A8%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%EF%BC%88%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%EF%BC%89">6.3.5 求解模线性方程（线性同余方程）</a></li>
<li><a href="#636-%E6%B1%82%E8%A7%A3%E6%A8%A1%E7%9A%84%E9%80%86%E5%85%83">6.3.6 求解模的逆元</a></li>
<li><a href="#637-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86">6.3.7 中国剩余定理</a></li>
<li><a href="#638-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0">6.3.8 最小公倍数</a></li>
<li><a href="#639-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0">6.3.9 分解质因数</a></li>
<li><a href="#6310-%E5%9B%A0%E6%95%B0%E4%B8%AA%E6%95%B0">6.3.10 因数个数</a></li>
<li><a href="#6311-%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A">6.3.11 素数判定</a><ul>
<li><a href="#63111-miller-rabin-primality-test">6.3.11.1 Miller Rabin Primality Test</a></li>
</ul>
</li>
<li><a href="#6312-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">6.3.12 进制转换</a></li>
<li><a href="#6313-a--c">6.3.13 A / C</a></li>
<li><a href="#6314-%E8%B4%A8%E6%95%B0%E8%A1%A8">6.3.14 质数表</a></li>
<li><a href="#6315-fast-exponention">6.3.15 Fast Exponention</a></li>
<li><a href="#6316-fast-fourier-transform-fft">6.3.16 Fast Fourier Transform FFT</a></li>
</ul>
</li>
<li><a href="#64-game-theory-%E5%8D%9A%E5%BC%88%E8%AE%BA">6.4 Game Theory 博弈论</a><ul>
<li><a href="#641-impartial-combinatorial-game">6.4.1 Impartial Combinatorial Game</a><ul>
<li><a href="#6411-nim-game">6.4.1.1 Nim Game</a></li>
<li><a href="#6411-composite-games-%E2%80%93-sprague-grundy-theorem-and-nim-value">6.4.1.1 Composite Games – Sprague-Grundy Theorem and Nim Value</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-geometry">7. Geometry</a><ul>
<li><a href="#71-2-dimension-space">7.1 2-Dimension Space</a><ul>
<li><a href="#711-template-of-point">7.1.1 Template of Point</a></li>
<li><a href="#712-%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98-%E5%8F%89%E4%B9%98">7.1.2 向量点乘 叉乘</a></li>
<li><a href="#713-dot-product">7.1.3 dot product</a></li>
<li><a href="#714-cross-product">7.1.4 cross product</a></li>
<li><a href="#715-%E7%9B%B4%E7%BA%BF%E5%85%AC%E5%BC%8F">7.1.5 直线公式</a></li>
<li><a href="#716-convex-hull">7.1.6 Convex Hull</a><ul>
<li><a href="#gift-wrapping">Gift Wrapping</a></li>
<li><a href="#quickhull">QuickHull</a></li>
<li><a href="#graham-scan">Graham scan</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-tricks--miscellaneous">8. Tricks + Miscellaneous</a><ul>
<li><a href="#81-bit-manipulation">8.1 Bit Manipulation</a></li>
<li><a href="#81-cantor-expansion--reverse-cantor-expansion">8.1 Cantor Expansion / Reverse Cantor Expansion</a></li>
<li><a href="#82-pass-2-d-array">8.2 pass 2-D array</a></li>
<li><a href="#83-binary-display">8.3 Binary Display</a></li>
<li><a href="#84-fast-log">8.4 Fast Log</a></li>
<li><a href="#85-squre-root">8.5 Squre Root</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="1-basic">1. Basic</h2>
<h3 id="1-1-c-solution-template">1.1 C++ Solution Template</h3>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEBUG false</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OJ_DEBUG</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> $(x) {<span class="hljs-meta-keyword">if</span> (DEBUG) {cout &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">": "</span>; {x} cout &lt;&lt; endl;}}</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _(x) {cout &lt;&lt; #x &lt;&lt; <span class="hljs-string">" = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;}</span>

const double E = <span class="hljs-number">1e-8</span>;
const double PI = acos(<span class="hljs-number">-1</span>);

using namespace std;

int main() {
<span class="hljs-symbol">    ios:</span>:sync_with_stdio(false);

}
</code></pre>
<h4 id="1-1-1-optional-include-list">1.1.1 Optional include list</h4>
<blockquote>
<p>Use it when there is no <code>bits/stdc++.h</code></p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
</code></pre>
<h3 id="1-2-strings">1.2 Strings</h3>
<h4 id="1-2-1-c-string">1.2.1 C++ String</h4>
<h5 id="read-one-line">read one line</h5>
<p>getline()</p>
<pre><code class="lang-C++"><span class="hljs-built_in">string</span> a;
getline(<span class="hljs-built_in">cin</span>, a);
<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;
</code></pre>
<p>Input</p>
<pre><code>Hello World!!!
</code></pre><p>Output</p>
<pre><code>Hello World!!!
</code></pre><h5 id="convert-to-char-array">Convert to char array</h5>
<pre><code class="lang-C++"><span class="hljs-built_in">string</span> cppstr = <span class="hljs-string">"this is a string"</span>;
<span class="hljs-keyword">char</span> target[<span class="hljs-number">1024</span>];
<span class="hljs-built_in">strcpy</span>(target, cppstr.c_str());
</code></pre>
<h4 id="1-2-2-c-string-character-array-">1.2.2 C String (Character Array)</h4>
<h5 id="input-c-string">Input C String</h5>
<p>gets()</p>
<blockquote>
<p>Reads characters from the standard input (stdin) and stores them as a C string into str until a newline character or the end-of-file is reached.</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-keyword">char</span> s[<span class="hljs-number">12</span>];
gets(s);
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\""</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">"\""</span> &lt;&lt; <span class="hljs-string">", length: "</span> &lt;&lt; <span class="hljs-built_in">strlen</span>(s) &lt;&lt; <span class="hljs-built_in">endl</span>;
</code></pre>
<p>Input</p>
<pre><code>hello world
<span class="hljs-keyword">new</span> <span class="hljs-built_in">line</span>
</code></pre><p>Output</p>
<pre><code><span class="hljs-string">"hello world"</span>, <span class="hljs-built_in">length</span>: <span class="hljs-number">11</span>
</code></pre><h5 id="convert-to-c-string">Convert to C++ string</h5>
<pre><code class="lang-c++"><span class="hljs-keyword">char</span> arrstr[] = <span class="hljs-string">"this is a string"</span>;
<span class="hljs-built_in">string</span> target = <span class="hljs-built_in">string</span>(arr);
</code></pre>
<h3 id="1-3-stl-algorithm">1.3 STL Algorithm</h3>
<blockquote>
<p>Include the algorithm library if you do not use the solution template.</p>
</blockquote>
<pre><code class="lang-C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
</code></pre>
<h4 id="1-3-1-permutation">1.3.1 Permutation</h4>
<p>Usage</p>
<pre><code class="lang-c++"><span class="hljs-keyword">bool </span>next_permutation (<span class="hljs-keyword">BidirectionalIterator </span>first, <span class="hljs-keyword">BidirectionalIterator </span>last)<span class="hljs-comment">;</span>
<span class="hljs-keyword">bool </span>next_permutation (<span class="hljs-keyword">BidirectionalIterator </span>first, <span class="hljs-keyword">BidirectionalIterator </span>last, <span class="hljs-built_in">Compare</span> comp)<span class="hljs-comment">;</span>
</code></pre>
<p>Example</p>
<pre><code class="lang-C++"><span class="hljs-comment">// next_permutation example</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// std::cout</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span>    <span class="hljs-comment">// std::next_permutation, std::sort</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> myints[] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};

  <span class="hljs-built_in">std</span>::sort (myints,myints+<span class="hljs-number">3</span>);

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The 3! possible permutations with 3 elements:\n"</span>;
  <span class="hljs-keyword">do</span> {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; myints[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; myints[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; myints[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">'\n'</span>;
  } <span class="hljs-keyword">while</span> ( <span class="hljs-built_in">std</span>::next_permutation(myints,myints+<span class="hljs-number">3</span>) );

  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After loop: "</span> &lt;&lt; myints[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; myints[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; myints[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">'\n'</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Output</p>
<pre><code>The 3! possible permutations with<span class="hljs-number"> 3 </span>elements:
1<span class="hljs-number"> 2 </span>3
1<span class="hljs-number"> 3 </span>2
2<span class="hljs-number"> 1 </span>3
2<span class="hljs-number"> 3 </span>1
3<span class="hljs-number"> 1 </span>2
3<span class="hljs-number"> 2 </span>1
After loop:<span class="hljs-number"> 1 </span>2 3
</code></pre><h4 id="1-3-2-binary-search">1.3.2 Binary Search</h4>
<p>Usage</p>
<pre><code class="lang-C++">bool binary_search (ForwardIterator <span class="hljs-built_in">first</span>, ForwardIterator <span class="hljs-built_in">last</span>, const T&amp; val, Compare comp);
// <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> found, <span class="hljs-literal">false</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>
</code></pre>
<h4 id="1-3-3-lower-bound">1.3.3 Lower Bound</h4>
<blockquote>
<p>Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.</p>
</blockquote>
<p>Usage</p>
<pre><code class="lang-c++">ForwardIterator lower_bound (ForwardIterator <span class="hljs-keyword">first</span>, ForwardIterator <span class="hljs-keyword">last</span>, const T&amp; val, Compare comp);
</code></pre>
<h4 id="1-3-4-swap">1.3.4 Swap</h4>
<p>Usage</p>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span> <span class="hljs-params">(T&amp; a, T&amp; b)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iter_swap</span> <span class="hljs-params">(ForwardIterator1 a, ForwardIterator2 b)</span></span>;
</code></pre>
<p><code>iter_swap</code> example</p>
<pre><code class="lang-C++"><span class="hljs-keyword">int</span> myints[]={<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span> };              <span class="hljs-comment">//   myints:  10  20  30  40  50</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; myvector (<span class="hljs-number">4</span>,<span class="hljs-number">99</span>);            <span class="hljs-comment">// myvector:  99  99  99  99</span>

<span class="hljs-built_in">std</span>::iter_swap(myints + <span class="hljs-number">3</span>,myvector.begin() + <span class="hljs-number">2</span>); <span class="hljs-comment">//   myints:  99  20  30 [99] 50</span>
                                             <span class="hljs-comment">// myvector:  10  99 [40] 99</span>
</code></pre>
<h4 id="1-3-5-heap">1.3.5 Heap</h4>
<ul>
<li>make_heap: Rearranges the elements in the range [first,last) in such a way that they form a heap. The element with the highest value is always pointed by first.</li>
<li>pop_heap: Rearranges the elements in the heap range [first,last) in such a way that the part considered a heap is shortened by one: The element with the highest value is moved to (last-1).</li>
<li>push_heap: Given a heap in the range [first,last-1), this function extends the range considered a heap to [first,last) by placing the value in (last-1) into its corresponding location within it.</li>
<li>sort_heap: Sorts the elements in the heap range [first,last) into ascending order.</li>
</ul>
<p>Usage</p>
<pre><code class="lang-c++"><span class="hljs-attribute">void</span> make_heap (RandomAccessIterator first, RandomAccessIterator <span class="hljs-literal">last</span>, Compare comp);
<span class="hljs-attribute">void</span> pop_heap (RandomAccessIterator first, RandomAccessIterator <span class="hljs-literal">last</span>, Compare comp);
<span class="hljs-attribute">void</span> push_heap (RandomAccessIterator first, RandomAccessIterator <span class="hljs-literal">last</span>, Compare comp);
<span class="hljs-attribute">void</span> sort_heap (RandomAccessIterator first, RandomAccessIterator <span class="hljs-literal">last</span>); <span class="hljs-attribute">Compare</span> comp);
</code></pre>
<h4 id="1-3-6-sort">1.3.6 Sort</h4>
<blockquote>
<p>Sorts the elements in the range [first,last) into ascending order.
<code>stable_sort</code> preserves the relative order of the elements with equivalent values.</p>
</blockquote>
<p>Usage</p>
<pre><code class="lang-c++">void <span class="hljs-built_in">sort</span> (RandomAccessIterator <span class="hljs-built_in">first</span>, RandomAccessIterator <span class="hljs-built_in">last</span>, Compare comp);
void stable_sort ( RandomAccessIterator <span class="hljs-built_in">first</span>, RandomAccessIterator <span class="hljs-built_in">last</span>, Compare comp );
</code></pre>
<h4 id="1-3-7-compare">1.3.7 Compare</h4>
<h5 id="using-lambda-expression">Using lambda expression</h5>
<pre><code class="lang-c++"><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-keyword">const</span> T&amp; a, <span class="hljs-keyword">const</span> T&amp; b) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; };
<span class="hljs-built_in">set</span>&lt;T, <span class="hljs-keyword">decltype</span>(cmp)&gt; a_set_with_customized_comparator(cmp);
</code></pre>
<h5 id="compare-function">Compare function</h5>
<blockquote>
<p>Binary function that accepts two elements in the range as arguments, and returns a value convertible to bool. It should returns true if the first element is considered to be &quot;smaller&quot; than the second one.</p>
</blockquote>
<p>Using by <code>sort</code>, <code>make_heap</code> and etc.</p>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">myfunction</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span> </span>{ <span class="hljs-keyword">return</span> (i&lt;j); }
</code></pre>
<h5 id="define-operator-">Define operator &lt;()</h5>
<p>Member function</p>
<blockquote>
<p>recommended // can use for priority_queue, sort, <ADD MORE HERE></p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> Edge {
   <span class="hljs-keyword">int</span> <span class="hljs-keyword">from</span>, to, weight;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(Edge that) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> weight &gt; that.weight;
    }
};
</code></pre>
<p>verbal version</p>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> Edge {
   <span class="hljs-keyword">int</span> <span class="hljs-keyword">from</span>, to, weight;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Edge&amp; that) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;weight &gt; that.weight;
    }
};
</code></pre>
<p>Non-member function</p>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> Edge {
    <span class="hljs-keyword">int</span> from, to, weight;
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(Edge a, Edge b) {
        <span class="hljs-keyword">return</span> a.weight &gt; b.weight;
    }
};
</code></pre>
<h5 id="define-operator-">Define operator()()</h5>
<blockquote>
<p>You can use comparison function for STL containers by passing them as the first argument of the constructor, and specifying the function type as the additional template argument. For example:</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span> (*)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; s(cmp);
</code></pre>
<blockquote>
<p>A functor, or a function object, is an object that can behave like a function. This is done by defining operator()() of the class. In this case, implement operator()() as a comparison function:</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; occurrences;
<span class="hljs-keyword">struct</span> cmp {
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
        <span class="hljs-keyword">return</span> occurrences[a] &lt; occurrences[b];
    }
};
<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>, cmp&gt; s;
priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, cmp&gt; pq;
</code></pre>
<p>Used by <code>priority_queue</code>.</p>
<h3 id="1-4-stl-containers">1.4 STL Containers</h3>
<p>A container is a holder object that stores a collection of other objects (its elements). They are implemented as class templates, which allows a great flexibility in the types supported as elements.</p>
<h4 id="1-4-1-map">1.4.1 Map</h4>
<blockquote>
<p>Maps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order.</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span>
</code></pre>
<h5 id="define-a-map">Define a Map</h5>
<pre><code class="lang-c++">template &lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Key</span>,                                     <span class="hljs-type">// map::key_type</span></span>
           <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>,                                       <span class="hljs-type">// map::mapped_type</span></span>
           <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compare</span> = <span class="hljs-title">less</span>&lt;<span class="hljs-type">Key</span>&gt;,                     <span class="hljs-type">// map::key_compare</span></span>
           <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alloc</span> = <span class="hljs-title">allocator</span>&lt;<span class="hljs-type">pair&lt;const Key,T</span>&gt; &gt;    // <span class="hljs-title">map</span>:<span class="hljs-type">:allocator_type</span></span>
           &gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">map</span>;</span>
</code></pre>
<h5 id="commonly-used-method">Commonly used method</h5>
<pre><code><span class="hljs-function"><span class="hljs-title">begin</span><span class="hljs-params">()</span></span>
<span class="hljs-function"><span class="hljs-title">end</span><span class="hljs-params">()</span></span>

<span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span>
<span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>

operator[] <span class="hljs-comment">// if not found, insert one</span>

<span class="hljs-function"><span class="hljs-title">insert</span><span class="hljs-params">(pair&lt;first type, second type)</span></span>
<span class="hljs-function"><span class="hljs-title">erase</span><span class="hljs-params">()</span></span>
<span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span>

<span class="hljs-function"><span class="hljs-title">find</span><span class="hljs-params">()</span></span> <span class="hljs-comment">// if not found, return end()</span>
<span class="hljs-function"><span class="hljs-title">count</span><span class="hljs-params">()</span></span> <span class="hljs-comment">// return 1 or 0</span>
</code></pre><blockquote>
<p>TODO add more interface</p>
</blockquote>
<h5 id="red-black-tree">Red-black Tree</h5>
<p>C++ map is implemented as a red-black tree.</p>
<p>A red–black tree is a data structure which is a type of self-balancing binary search tree.</p>
<p>In addition to the requirements imposed on a binary search tree the following must be satisfied by a red–black tree:</p>
<ol>
<li>A node is either red or black.</li>
<li>The root is black. (This rule is sometimes omitted. Since the root can always be changed from red to black, but not necessarily vice-versa, this rule has little effect on analysis.)</li>
<li>All leaves (NIL) are black. (All leaves are same color as the root.)</li>
<li>Every red node must have two black child nodes.</li>
<li>Every path from a given node to any of its descendant leaves contains the same number of black nodes.</li>
</ol>
<h5 id="hash-map-unordered-map-">Hash Map (Unordered Map)</h5>
<blockquote>
<p>Unordered map is implemented as a hash table.</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
</code></pre>
<blockquote>
<p>Unordered maps are associative containers that store elements formed by the combination of a key value and a mapped value, and which allows for fast retrieval of individual elements based on their keys.</p>
</blockquote>
<pre><code class="lang-c++">template &lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Key</span>,                                    <span class="hljs-type">// unordered_map::key_type</span></span>
           <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>,                                      <span class="hljs-type">// unordered_map::mapped_type</span></span>
           <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hash</span> = <span class="hljs-title">hash</span>&lt;<span class="hljs-type">Key</span>&gt;,                       <span class="hljs-type">// unordered_map::hasher</span></span>
           <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pred</span> = <span class="hljs-title">equal_to</span>&lt;<span class="hljs-type">Key</span>&gt;,                   <span class="hljs-type">// unordered_map::key_equal</span></span>
           <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alloc</span> = <span class="hljs-title">allocator</span>&lt;<span class="hljs-type"> pair&lt;const Key,T</span>&gt; &gt;  // <span class="hljs-title">unordered_map</span>:<span class="hljs-type">:allocator_type</span></span>
           &gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">unordered_map</span>;</span>
</code></pre>
<h5 id="commonly-used-method">Commonly used method</h5>
<pre><code class="lang-C++"><span class="hljs-comment">// most are similar to map</span>
</code></pre>
<p>// TODO add more interface</p>
<h4 id="1-4-2-pair">1.4.2 Pair</h4>
<h4 id="1-4-3-vector">1.4.3 Vector</h4>
<h5 id="constructor">Constructor</h5>
<pre><code class="lang-c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; second (<span class="hljs-number">4</span>,<span class="hljs-number">100</span>);  <span class="hljs-comment">// four ints with value 100</span>
</code></pre>
<h5 id="methods">Methods</h5>
<ul>
<li>begin(), end()</li>
<li>front(), back()</li>
<li>clear()</li>
<li>size()</li>
<li>push_back(const value_type&amp; val)</li>
<li>pop_back()</li>
</ul>
<h4 id="1-4-4-list">1.4.4 List</h4>
<blockquote>
<p>List containers are implemented as doubly-linked lists.</p>
</blockquote>
<h5 id="methods">Methods</h5>
<ul>
<li>begin(), end()</li>
<li>front(), back()</li>
<li>clear()</li>
<li>push_front(const value_type&amp; val)</li>
<li>push_back(const value_type&amp; val)</li>
<li>pop_front(): remove the first element.</li>
<li>pop_back(): remove the last element.</li>
<li>remove(const value_type&amp; val): remove all elements of value val.</li>
<li>insert(iterator position, const value_type&amp; val)</li>
<li>size()</li>
<li>reverse()</li>
<li>sort(), sort (Compare comp)</li>
<li></li>
<li>resize()</li>
<li>reserve()</li>
</ul>
<h4 id="1-4-5-queue">1.4.5 Queue</h4>
<pre><code class="lang-C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
</code></pre>
<p>Constructor</p>
<pre><code class="lang-C++"><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; my_queue;
<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; my_queue (my_list);
<span class="hljs-comment">// use list&lt;int&gt; as container, copy my_list into my_queue</span>
</code></pre>
<p>Methods</p>
<pre><code class="lang-C++"><span class="hljs-keyword">void</span> <span class="hljs-built_in">queue</span>::push(<span class="hljs-keyword">const</span> value_type&amp; val);
<span class="hljs-keyword">void</span> <span class="hljs-built_in">queue</span>::pop();
<span class="hljs-keyword">bool</span> <span class="hljs-built_in">queue</span>::empty() <span class="hljs-keyword">const</span>;
size_type <span class="hljs-built_in">queue</span>::size() <span class="hljs-keyword">const</span>;
const_reference&amp; <span class="hljs-built_in">queue</span>::front() <span class="hljs-keyword">const</span>;
</code></pre>
<h4 id="1-4-6-double-ended-queue">1.4.6 Double-ended Queue</h4>
<pre><code class="lang-C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;dequeue&gt;</span></span>
</code></pre>
<h4 id="1-4-7-stack">1.4.7 Stack</h4>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span>
</code></pre>
<p>Constructor</p>
<pre><code class="lang-C++"><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; my_stack (my_data);
<span class="hljs-comment">// use vector&lt;int&gt; as container, copy my_data into my_stack</span>

<span class="hljs-keyword">bool</span> <span class="hljs-built_in">stack</span>::empty() <span class="hljs-keyword">const</span>;
size_type <span class="hljs-built_in">stack</span>::size() <span class="hljs-keyword">const</span>;
const_reference&amp; <span class="hljs-built_in">stack</span>::top() <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">void</span> <span class="hljs-built_in">stack</span>::push (<span class="hljs-keyword">const</span> value_type&amp; val);
<span class="hljs-keyword">void</span> <span class="hljs-built_in">stack</span>::pop();
</code></pre>
<h4 id="1-4-8-priority-queue">1.4.8 Priority Queue</h4>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
</code></pre>
<pre><code class="lang-C++"><span class="hljs-comment">// constructor</span>
priority_queue&lt;<span class="hljs-keyword">int</span>&gt; my_priority_queue;
priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; two_priority_queue; <span class="hljs-comment">// if use greater&lt;int&gt;, must have vector&lt;int&gt;</span>
priority_queue&lt;My_type, <span class="hljs-built_in">vector</span>&lt;My_type&gt;, Comparator_class&gt; my_priority_queue (my_data.begin(), my_data.end()); <span class="hljs-comment">// use Comparator_class as comparator, use vector&lt;My_type&gt; as container, copy my_data into my_priority_queue</span>

<span class="hljs-keyword">bool</span> priority_queue::empty() <span class="hljs-keyword">const</span>; <span class="hljs-comment">// return true if empty, false if not</span>
size_type priority_queue::size() <span class="hljs-keyword">const</span>; <span class="hljs-comment">// return size of queue</span>
const_reference priority_queue::top() <span class="hljs-keyword">const</span>; <span class="hljs-comment">// returns a constant reference to the top element</span>
<span class="hljs-keyword">void</span> priority_queue::push(<span class="hljs-keyword">const</span> value_type&amp; val); <span class="hljs-comment">// inserts a new element, initialize to val</span>
<span class="hljs-keyword">void</span> priority_queue::pop(); <span class="hljs-comment">// removes the element on top</span>
</code></pre>
<pre><code class="lang-C++"><span class="hljs-keyword">struct</span> My_type {
    <span class="hljs-keyword">int</span> weight;
    <span class="hljs-keyword">int</span> other;
};

<span class="hljs-keyword">struct</span> My_class_for_compare {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>() (My_type a, My_type b) {
            <span class="hljs-built_in">return</span> a.weight &lt; b.weight;
        }
};

vector&lt;My_type&gt; my_vector = {(My_type){<span class="hljs-number">2</span>, <span class="hljs-number">789</span>}, (My_type){<span class="hljs-number">1</span>, <span class="hljs-number">127</span>}, (My_type){<span class="hljs-number">3</span>, <span class="hljs-number">456</span>}};

priority_queue&lt;My_type, vector&lt;My_type&gt;, My_class_for_compare&gt; one_priority_queue (my_vector.<span class="hljs-built_in">begin</span>(), my_vector.<span class="hljs-built_in">end</span>());
one_priority_queue.push((My_type){<span class="hljs-number">4</span>, <span class="hljs-number">483</span>});
<span class="hljs-built_in">while</span> (one_priority_queue.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) {
    My_type temp = one_priority_queue.top();
    one_priority_queue.pop();
    SHOW_B(temp.weight, temp.other);
}

vector&lt;<span class="hljs-keyword">int</span>&gt; my_int = {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>};

priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; two_priority_queue (my_int.<span class="hljs-built_in">begin</span>(), my_int.<span class="hljs-built_in">end</span>());
<span class="hljs-built_in">while</span> (two_priority_queue.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) {
    SHOW_A(two_priority_queue.top());
    two_priority_queue.pop();
}

priority_queue&lt;<span class="hljs-keyword">int</span>&gt; three_priority_queue (my_int.<span class="hljs-built_in">begin</span>(), my_int.<span class="hljs-built_in">end</span>());
<span class="hljs-built_in">while</span> (three_priority_queue.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) {
    SHOW_A(three_priority_queue.top());
    three_priority_queue.pop();
}


<span class="hljs-comment">// output</span>
<span class="hljs-comment">// temp.weight = 4, temp.other = 483</span>
<span class="hljs-comment">// temp.weight = 3, temp.other = 456</span>
<span class="hljs-comment">// temp.weight = 2, temp.other = 789</span>
<span class="hljs-comment">// temp.weight = 1, temp.other = 127</span>
<span class="hljs-comment">// two_priority_queue.top() = 1</span>
<span class="hljs-comment">// two_priority_queue.top() = 2</span>
<span class="hljs-comment">// two_priority_queue.top() = 3</span>
<span class="hljs-comment">// three_priority_queue.top() = 3</span>
<span class="hljs-comment">// three_priority_queue.top() = 2</span>
<span class="hljs-comment">// three_priority_queue.top() = 1</span>
</code></pre>
<h2 id="2-advanced-data-structures">2. Advanced Data Structures</h2>
<h3 id="2-1-heap">2.1 Heap</h3>
<h3 id="2-2-tree">2.2 Tree</h3>
<h4 id="2-2-0-tree-traversal">2.2.0 Tree Traversal</h4>
<h4 id="2-2-1-pointer-jumping">2.2.1 Pointer Jumping</h4>
<blockquote>
<p>Initialize: O(Nlog(N))</p>
<p>Query: O(Nlog(N))</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_NODE 100030</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_NODE_LOG 20</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TREE_ROOT 0</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAX_NODE];
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent_jump[MAX_NODE];
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; path;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur = TREE_ROOT)</span> </span>{
    <span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">int</span> index = path.size() - d;
        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">break</span>;
        parent_jump[cur].push_back(path[index]);
        d &lt;&lt;= <span class="hljs-number">1</span>;
    }
    path.push_back(cur);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].size(); i++) {
        <span class="hljs-keyword">int</span> nx = g[cur][i];
        <span class="hljs-keyword">if</span> (cur == TREE_ROOT || nx != parent_jump[cur][<span class="hljs-number">0</span>]) {
            init_jump(nx);
        }
    }
    path.pop_back();
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">go_up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> dis)</span> </span>{
    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (mask &lt;= dis) {
        <span class="hljs-keyword">if</span> (dis &amp; mask)
            cur = parent_jump[cur][index];
        mask &lt;&lt;= <span class="hljs-number">1</span>;
        index++;
    }
    <span class="hljs-keyword">return</span> cur;
}
</code></pre>
<h4 id="2-2-2-heavy-light-decomposition">2.2.2 Heavy-Light Decomposition</h4>
<blockquote>
<p>Build: O(N)</p>
<p>Overhead: O(log(N))</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-comment">// </span>
<span class="hljs-comment">// CodeForces 593D</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// sol 1 - path must &lt; 64 - not straightforward</span>
<span class="hljs-comment">// sol 2 - Heavy-Light Decomposition + Segment Tree + Math - not straightforward</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// floor( floor(A / B) / C) = floor(A / (B * C))</span>
<span class="hljs-comment">// </span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span>
<span class="hljs-comment">// #include &lt;unordered_set&gt;</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span>
<span class="hljs-comment">// #include &lt;unordered_map&gt;</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SHOW(...) {;}</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REACH_HERE {;}</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG(s, ...) {;}</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOGLN(s, ...) {;}</span>

<span class="hljs-comment">// #undef HHHDEBUG</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HHHDEBUG</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"template.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) {
        ret++;
        x /= <span class="hljs-number">10</span>;
    }
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">will_boom</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b)</span> </span>{
    <span class="hljs-keyword">if</span> (a == ULLONG_MAX || b == ULLONG_MAX)
        <span class="hljs-keyword">return</span> ULLONG_MAX;

    <span class="hljs-keyword">int</span> la = len(a);
    <span class="hljs-keyword">int</span> lb = len(b);
    <span class="hljs-keyword">if</span> (la - <span class="hljs-number">1</span> + lb - <span class="hljs-number">1</span> + <span class="hljs-number">1</span> &gt; <span class="hljs-number">20</span>)
        <span class="hljs-keyword">return</span> ULLONG_MAX;
    <span class="hljs-keyword">return</span> a * b;
}

<span class="hljs-keyword">struct</span> SegmentTree {
    <span class="hljs-keyword">struct</span> Node {
        <span class="hljs-keyword">int</span> l;
        <span class="hljs-keyword">int</span> r;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> accu;
    };

    <span class="hljs-keyword">int</span> r_most;
    <span class="hljs-built_in">vector</span>&lt;Node&gt; node;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rm)</span> </span>{
        r_most = rm;

        <span class="hljs-keyword">int</span> tree_range = r_most + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tree_range &lt;= <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> ;

        <span class="hljs-keyword">int</span> tree_size = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (tree_size &lt;= tree_range)
            tree_size &lt;&lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (__builtin_popcount(tree_range) != <span class="hljs-number">1</span>) <span class="hljs-comment">// count number of '1' bits</span>
            tree_size &lt;&lt;= <span class="hljs-number">1</span>;

        node.resize(tree_size);

        Node&amp; root = node[<span class="hljs-number">1</span>];
        root.l = <span class="hljs-number">0</span>;
        root.r = r_most;
        root.accu = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; node.size(); i++) {
            Node&amp; cur = node[i];
            cur.accu = <span class="hljs-number">1</span>;

            <span class="hljs-keyword">const</span> Node&amp; par = node[i / <span class="hljs-number">2</span>];
            <span class="hljs-keyword">if</span> (par.l == par.r)
                <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">int</span> m = (par.l + par.r) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>) {
                cur.l = m + <span class="hljs-number">1</span>;
                cur.r = par.r;
            }
            <span class="hljs-keyword">else</span> {
                cur.l = par.l;
                cur.r = m;
            }
        }

        <span class="hljs-comment">// SHOW("init")</span>
        <span class="hljs-comment">// show();</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        SHOW(<span class="hljs-string">"SegmentTree"</span>, r_most)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; node.size(); i++) {
            Node&amp; cur = node[i];
            SHOW(i, cur.l, cur.r, cur.accu)
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> new_y, <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>)</span> </span>{
        Node&amp; cur = node[i];

        <span class="hljs-keyword">if</span> (cur.l == cur.r) {
            cur.accu = new_y;
            <span class="hljs-keyword">return</span> ;
        }

        <span class="hljs-keyword">int</span> m = (cur.l + cur.r) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> il = i * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> ir = il + <span class="hljs-number">1</span>;

        <span class="hljs-keyword">if</span> (l &lt;= m)
            update(l, r, new_y, il);
        <span class="hljs-keyword">else</span>
            update(l, r, new_y, ir);

        cur.accu = will_boom(node[il].accu, node[ir].accu);
    }

    <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>)</span> </span>{
        <span class="hljs-keyword">if</span> (l &gt; r)
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

        Node&amp; cur = node[i];
        <span class="hljs-keyword">if</span> (l &lt;= cur.l &amp;&amp; cur.r &lt;= r)
            <span class="hljs-keyword">return</span> cur.accu;

        <span class="hljs-keyword">if</span> (r &lt; cur.l || cur.r &lt; l) {
            REACH_HERE
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        }

        <span class="hljs-keyword">int</span> m = (cur.l + cur.r) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> il = i * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> ir = il + <span class="hljs-number">1</span>;

        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (l &lt;= m) {
            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp_l = query(l, r, il);
            ans = will_boom(ans, temp_l);
        }

        <span class="hljs-keyword">if</span> (m &lt; r) {
            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp_r = query(l, r, ir);
            ans = will_boom(ans, temp_r);
        }

        <span class="hljs-keyword">return</span> ans;
    }
};

<span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-built_in">map</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-keyword">int</span>&gt; node_edge;

    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> from;
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y;
    };

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">200005</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn)</span> </span>{
        n = nn;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)
            g[i].clear();
        edge.clear();
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> val_y)</span> </span>{
        Edge e1 = {x, y, val_y};
        g[x].push_back(edge.size());
        node_edge[make_pair(x, y)] = edge.size();
        edge.push_back(e1);

        Edge e2 = {y, x, val_y};
        g[y].push_back(edge.size());
        node_edge[make_pair(y, x)] = edge.size();
        edge.push_back(e2);

        <span class="hljs-comment">// LOGLN("add edge %d - %d = %llu", x, y, val_y);</span>
    }

    <span class="hljs-keyword">int</span> parent[MAXNODE];
    <span class="hljs-keyword">int</span> size[MAXNODE];
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size_parent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
        <span class="hljs-keyword">int</span>&amp; s = size[cur] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].size(); i++) {
            <span class="hljs-keyword">int</span> ie = g[cur][i];
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            <span class="hljs-keyword">int</span> nx = e.to;
            <span class="hljs-keyword">if</span> (nx != parent[cur]) {
                parent[nx] = cur;
                s += size_parent(nx);    
            }
        }
        <span class="hljs-keyword">return</span> s;
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_size_parent</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"node %d: size %d, parent %d\n"</span>, i, size[i], parent[i]);
    }

    <span class="hljs-keyword">struct</span> Chain {
        <span class="hljs-keyword">int</span> head;
        <span class="hljs-keyword">int</span> head_depth;
        <span class="hljs-keyword">int</span> len;
    };
    <span class="hljs-built_in">vector</span>&lt;Chain&gt; chain;
    <span class="hljs-keyword">int</span> chain_total;
    <span class="hljs-keyword">int</span> chain_no[MAXNODE]; <span class="hljs-comment">// chain_no[node] == chain_index</span>
    <span class="hljs-keyword">int</span> chain_pos[MAXNODE]; <span class="hljs-comment">// chain_pos[node] == x'th node in the chain // 0 based</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hld</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> depth)</span> </span>{
        <span class="hljs-keyword">if</span> (chain_total == chain.size()) {
            Chain c = {cur, depth, <span class="hljs-number">0</span>};
            chain.push_back(c);
        }

        chain_no[cur] = chain_total;
        chain_pos[cur] = chain[chain_total].len;
        chain[chain_total].len++; <span class="hljs-comment">// 0 based, add later</span>

        <span class="hljs-keyword">if</span> (depth != <span class="hljs-number">0</span> &amp;&amp; g[cur].size() - <span class="hljs-number">1</span> == <span class="hljs-number">0</span>) 
            <span class="hljs-keyword">return</span> ;

        <span class="hljs-keyword">int</span> heavy = edge[g[cur][<span class="hljs-number">0</span>]].to;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].size(); i++) {
            <span class="hljs-keyword">int</span> ie = g[cur][i];
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            <span class="hljs-keyword">int</span> nx = e.to;
            <span class="hljs-keyword">if</span> (heavy == parent[cur] || (nx != parent[cur] &amp;&amp; size[nx] &gt; size[heavy]))
                heavy = nx;
        }

        hld(heavy, depth + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].size(); i++) {
            <span class="hljs-keyword">int</span> ie = g[cur][i];
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            <span class="hljs-keyword">int</span> nx = e.to;
            <span class="hljs-keyword">if</span> (nx != parent[cur] &amp;&amp; nx != heavy) {
                chain_total++;
                hld(nx, depth + <span class="hljs-number">1</span>);
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heavy_light_decomposition</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> root = <span class="hljs-number">1</span>;
        parent[root] = <span class="hljs-number">-1</span>;
        assert(n == size_parent(root));

        chain_total = <span class="hljs-number">0</span>;
        chain.clear();

        hld(root, <span class="hljs-number">0</span>);
        chain_total++;
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_hld</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"chain_total = %d\n"</span>, chain_total);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= chain_total; i++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"chain %d: len %d, head %d, head depth %d\n"</span>, i, chain[i].len, chain[i].head, chain[i].head_depth);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"node %d: chain %d, pos %d\n"</span>, i, chain_no[i], chain_pos[i]);
    }

    <span class="hljs-built_in">vector</span>&lt;SegmentTree&gt; st;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_sol</span><span class="hljs-params">()</span> </span>{
        st.resize(chain_total);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; st.size(); i++)
            st[i].init(chain[i].len - <span class="hljs-number">2</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edge.size(); i += <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[i];
            <span class="hljs-keyword">int</span> cn1 = chain_no[e.from];
            <span class="hljs-keyword">int</span> cn2 = chain_no[e.to];

            <span class="hljs-keyword">if</span> (cn1 == cn2) {
                <span class="hljs-keyword">int</span> cp1 = chain_pos[e.from];
                <span class="hljs-keyword">int</span> cp2 = chain_pos[e.to];
                <span class="hljs-keyword">if</span> (cp1 &gt; cp2)
                    swap(cp1, cp2);
                st[cn1].update(cp1, cp2 - <span class="hljs-number">1</span>, e.y);
            }
        }

        <span class="hljs-comment">// for (int i = 0; i &lt; chain_total; i++)</span>
        <span class="hljs-comment">//     st[i].show();</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span> </span>{
        p *= <span class="hljs-number">2</span>;
        Edge&amp; e = edge[p];
        e.y = edge[p + <span class="hljs-number">1</span>].y = c;

        <span class="hljs-keyword">int</span> cn1 = chain_no[e.from];
        <span class="hljs-keyword">int</span> cn2 = chain_no[e.to];
        <span class="hljs-keyword">if</span> (cn1 == cn2) {
            <span class="hljs-keyword">int</span> cp1 = chain_pos[e.from];
            <span class="hljs-keyword">int</span> cp2 = chain_pos[e.to];
            <span class="hljs-keyword">if</span> (cp1 &gt; cp2)
                swap(cp1, cp2);
            st[cn1].update(cp1, cp2 - <span class="hljs-number">1</span>, c);    
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y)</span> </span>{
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> accu = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">int</span> cn1 = chain_no[a];
            <span class="hljs-keyword">int</span> cn2 = chain_no[b];

            <span class="hljs-keyword">if</span> (chain[cn1].head_depth &lt; chain[cn2].head_depth)
                swap(a, b), swap(cn1, cn2);

            <span class="hljs-keyword">if</span> (cn1 == cn2) {
                <span class="hljs-keyword">int</span> cp1 = chain_pos[a];
                <span class="hljs-keyword">int</span> cp2 = chain_pos[b];
                <span class="hljs-keyword">if</span> (cp1 &gt; cp2)
                    swap(cp1, cp2);
                <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = st[cn1].query(cp1, cp2 - <span class="hljs-number">1</span>);
                accu = will_boom(accu, temp);
                <span class="hljs-keyword">break</span>;
            }


            <span class="hljs-keyword">if</span> (a != chain[cn1].head) {
                <span class="hljs-keyword">int</span> ha = chain[cn1].head;
                <span class="hljs-keyword">int</span> cp1 = chain_pos[ha];
                <span class="hljs-keyword">int</span> cp2 = chain_pos[a];
                <span class="hljs-keyword">if</span> (cp1 &gt; cp2)
                    swap(cp1, cp2);
                <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = st[cn1].query(cp1, cp2 - <span class="hljs-number">1</span>);
                accu = will_boom(accu, temp);
                a = ha;
            }

            <span class="hljs-keyword">int</span> pa = parent[a];
            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = edge[node_edge[make_pair(a, pa)]].y;
            accu = will_boom(temp, accu);
            a = parent[a];
        }

        <span class="hljs-keyword">if</span> (accu == <span class="hljs-number">0</span>) <span class="hljs-comment">// no idea why would be 0</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> y / accu;
    }
};

<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">int</span> m;
Graph g;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;m);
    g.init(n);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> x, y;
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> val_y;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %llu"</span>, &amp;x, &amp;y, &amp;val_y);
        g.add_e(x, y, val_y);
    }

    g.heavy_light_decomposition();
    <span class="hljs-comment">// g.show_hld();</span>
    g.init_sol(); 

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
        <span class="hljs-keyword">int</span> op;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;op);
        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">int</span> a, b;
            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y;
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %llu"</span>, &amp;a, &amp;b, &amp;y);
            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = g.query(a, b, y);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%llu\n"</span>, ans);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> p;
            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c;
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %llu"</span>, &amp;p, &amp;c);
            g.update(p - <span class="hljs-number">1</span>, c);
        }
    }
}
</code></pre>
<h4 id="2-2-3-lowest-common-ancestor">2.2.3 Lowest Common Ancestor</h4>
<blockquote>
<p>Reduction from LCA to RMQ</p>
<p>let n = number of nodes in the tree</p>
<p>preprocess: euler tour O(n) + RMQ init O(nlog(n))</p>
<p>query: RMQ O(1)</p>
<p><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/">tutorial</a></p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-comment">// lowest common ancestor LCA</span>
<span class="hljs-comment">// --&gt; range minimun range_minimum_query</span>
<span class="hljs-comment">// preprocess: O(3 * nlog(n))</span>
<span class="hljs-comment">// range_minimum_query: O(1)</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// 1471. Tree</span>
<span class="hljs-comment">// http://acm.timus.ru/problem.aspx?space=1&amp;num=1471</span>
<span class="hljs-comment">// Time limit: 2.0 second</span>
<span class="hljs-comment">// Memory limit: 64 MB</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// A weighted tree is given. You must find the distance between two given nodes.</span>
<span class="hljs-comment">// Input</span>
<span class="hljs-comment">// The first line contains the number of nodes of the tree n (1 ≤ n ≤ 50000).</span>
<span class="hljs-comment">// The nodes are numbered from 0 to n – 1.</span>
<span class="hljs-comment">// Each of the next n – 1 lines contains three integers u, v, w,</span>
<span class="hljs-comment">// which correspond to an edge with weight w (0 ≤ w ≤ 1000) connecting nodes u and v.</span>
<span class="hljs-comment">// The next line contains the number of queries m (1 ≤ m ≤ 75000).</span>
<span class="hljs-comment">// In each of the next m lines there are two integers.</span>
<span class="hljs-comment">// Output</span>
<span class="hljs-comment">// For each range_minimum_query, output the distance between the nodes with the given numbers.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Sample</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// input</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 1 0 1</span>
<span class="hljs-comment">// 2 0 1</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 0 1</span>
<span class="hljs-comment">// 0 2</span>
<span class="hljs-comment">// 1 2</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// output</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 2</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> len;
    };

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">1</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;

    <span class="hljs-keyword">int</span> root = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn, <span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>)</span> </span>{
        n = nn;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)
            g[i].clear();
        edge.clear();
        m *= <span class="hljs-number">2</span>;
        edge.reserve(m); <span class="hljs-comment">// may speedup // add_e too slow</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> len)</span> </span>{
        g[x].push_back(edge.size());
        edge.push_back((Edge){y, len});

        g[y].push_back(edge.size());
        edge.push_back((Edge){x, len});
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, edge[ie].to);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }

    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// --- start of LCA ---</span>
    <span class="hljs-comment">// </span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dis_to_root;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; first_visit_time; <span class="hljs-comment">// max possible number of visits to all nodes == 2 * number of nodes - 1</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; visit;
    <span class="hljs-keyword">int</span> visit_counter;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; rmq;

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">range_minimum_query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{ <span class="hljs-comment">// query [l, r]</span>
        <span class="hljs-keyword">if</span> (l &gt; r)
            swap(l, r);

        <span class="hljs-keyword">int</span> interval_len = r - l; <span class="hljs-comment">// (r - l + 1) - 1</span>

        <span class="hljs-keyword">int</span> first_half = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> ((<span class="hljs-number">1</span> &lt;&lt; first_half) &lt;= interval_len)
            first_half++;
        first_half--;

        <span class="hljs-keyword">int</span> second_half = r - (<span class="hljs-number">1</span> &lt;&lt; first_half) + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (first_visit_time[rmq[l][first_half]] &lt; first_visit_time[rmq[second_half][first_half]])
            <span class="hljs-keyword">return</span> rmq[l][first_half];
        <span class="hljs-keyword">return</span> rmq[second_half][first_half];
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
        <span class="hljs-keyword">return</span> range_minimum_query(first_visit_time[x], first_visit_time[y]);
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
        <span class="hljs-keyword">int</span> lca = get_lca(x, y);
        <span class="hljs-keyword">return</span> dis_to_root[x] + dis_to_root[y] - <span class="hljs-number">2</span> * dis_to_root[lca];
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">euler_tour</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
        visit[++visit_counter] = cur; <span class="hljs-comment">// v_t[node] = time // needed in case don't have two child</span>
        <span class="hljs-keyword">if</span> (first_visit_time[cur] == <span class="hljs-number">0</span>) <span class="hljs-comment">// if first time</span>
            first_visit_time[cur] = visit_counter; <span class="hljs-comment">// record time f_v_t[node] = time</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[cur]) {
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            <span class="hljs-keyword">int</span> nx = e.to;
            <span class="hljs-keyword">int</span> len = e.len;
            <span class="hljs-keyword">if</span> (first_visit_time[nx] == <span class="hljs-number">0</span>) {
                dis_to_root[nx] = dis_to_root[cur] + len;
                euler_tour(nx);
                visit[++visit_counter] = cur; <span class="hljs-comment">// every two child_visit_time have one parent_visit_time inserted between</span>
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_lca</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// O(Nlog(N)) </span>
        <span class="hljs-keyword">int</span> one_n = n + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> two_n = <span class="hljs-number">2</span> * one_n;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(one_n, <span class="hljs-number">0</span>).swap(dis_to_root);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(one_n, <span class="hljs-number">0</span>).swap(first_visit_time);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(two_n, <span class="hljs-number">0</span>).swap(visit);

        <span class="hljs-keyword">int</span> LOG_MAXLENGTH = log2(two_n) + <span class="hljs-number">2</span>;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(two_n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(LOG_MAXLENGTH)).swap(rmq);

        visit_counter = <span class="hljs-number">0</span>;
        euler_tour(root);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; visit_counter; i++)
            rmq[i][<span class="hljs-number">0</span>] = visit[i];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; LOG_MAXLENGTH; j++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; visit_counter; i++) {
                <span class="hljs-keyword">if</span> (i + (<span class="hljs-number">1</span> &lt;&lt; j) &gt; visit_counter)
                    <span class="hljs-keyword">break</span>;
                rmq[i][j] = rmq[i][j - <span class="hljs-number">1</span>];
                <span class="hljs-keyword">if</span> (first_visit_time[rmq[i][j - <span class="hljs-number">1</span>]] &gt; first_visit_time[rmq[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]])
                    rmq[i][j] = rmq[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j<span class="hljs-number">-1</span>];
            }
    }
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// --- end of LCA ---</span>
    <span class="hljs-comment">// </span>
};

<span class="hljs-keyword">int</span> n, m;
Graph g;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);
    g.init(n, n);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> x, y, d;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;d);
        g.add_e(x, y, d);
    }

    g.build_lca();

    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
        <span class="hljs-keyword">int</span> x, y;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;x, &amp;y);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, g.dist(x, y));
    }
}
</code></pre>
<p>Another implementation, only used by ZXZ.</p>
<pre><code class="lang-c++">const <span class="hljs-keyword">int</span> MAX_N = <span class="hljs-number">1</span>e5 + <span class="hljs-number">10</span>;
const <span class="hljs-keyword">int</span> MAX_LOG_N = <span class="hljs-number">21</span>;

struct node {
    <span class="hljs-keyword">int</span> baba;
    <span class="hljs-keyword">int</span> k, v;
    vector&lt;<span class="hljs-keyword">int</span>&gt; children;
};

node tree[MAX_N];  <span class="hljs-regexp">//</span> tree[<span class="hljs-number">0</span>] is <span class="hljs-keyword">not</span> used.


<span class="hljs-keyword">int</span> range_minimun_query(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) {
    <span class="hljs-regexp">//</span> calculate <span class="hljs-keyword">log</span>(right)
    <span class="hljs-keyword">if</span> (left &gt; right) swap(left, right);
    <span class="hljs-keyword">int</span> log_right = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> ((<span class="hljs-number">1</span> &lt;&lt; log_right) &lt;= right - left) log_right ++;
    log_right --;
    <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> the minimum from the lower level RMQ.
    bool is_lower = (first_visit[rm<span class="hljs-string">q[left]</span>[log_right]] &lt;
                     first_visit[rm<span class="hljs-string">q[right - (1&lt;&lt;log_right) + 1]</span>[log_right]]);
    <span class="hljs-keyword">return</span> is_lower ? rm<span class="hljs-string">q[left]</span>[log_right] : rm<span class="hljs-string">q[right - (1&lt;&lt;log_right) + 1]</span>[log_right];
}

void dfs_rm<span class="hljs-string">q(int cur)</span> {
    visit_count ++;
    visit[visit_count] = cur;
    <span class="hljs-keyword">if</span> (!first_visit[cur]) first_visit[cur] = visit_count;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tree[cur].children.size(); i++) {
        <span class="hljs-keyword">int</span> child = tree[cur].children[i];
        <span class="hljs-keyword">if</span> (first_visit[child]) <span class="hljs-keyword">continue</span>;
        level[child] = level[cur] + <span class="hljs-number">1</span>;
        dfs_rm<span class="hljs-string">q(child)</span>;
        visit_count ++;
        visit[visit_count] = cur;
    }
}

void init_rm<span class="hljs-string">q()</span> {
    dfs_rm<span class="hljs-string">q(1)</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= visit_count; i++) rm<span class="hljs-string">q[i]</span>[<span class="hljs-number">0</span>] = visit[i];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> log_level = <span class="hljs-number">1</span>; log_level &lt; MAX_LOG_N; log_level++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= visit_count; i++) {
            <span class="hljs-keyword">if</span> (i + (<span class="hljs-number">1</span>&lt;&lt;log_level) &gt; visit_count) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span> (first_visit[rm<span class="hljs-string">q[i]</span>[log_level - <span class="hljs-number">1</span>]] &lt;
                first_visit[rm<span class="hljs-string">q[i + (1&lt;&lt;(log_level-1))]</span>[log_level-<span class="hljs-number">1</span>]]) {
                rm<span class="hljs-string">q[i]</span>[log_level] = rm<span class="hljs-string">q[i]</span>[log_level - <span class="hljs-number">1</span>];
            } <span class="hljs-keyword">else</span> {
                rm<span class="hljs-string">q[i]</span>[log_level] = rm<span class="hljs-string">q[i + (1&lt;&lt;(log_level-1))]</span>[log_level-<span class="hljs-number">1</span>];
            }
        }
    }
}
</code></pre>
<h5 id="2-2-3-1-tarjan-s-off-line-algorithm">2.2.3.1 Tarjan&#39;s Off-line Algorithm</h5>
<blockquote>
<p>let n = number of ndoes of the tree, m = number of query</p>
<p>O(n + m)</p>
</blockquote>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TarjanOLCA</span><span class="hljs-params">(u)</span>
     <span class="hljs-title">MakeSet</span><span class="hljs-params">(u)</span></span>;
     u.ancestor := u;
     <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> v <span class="hljs-keyword">in</span> u.children <span class="hljs-keyword">do</span>
         TarjanOLCA(v);
         Union(u,v);
         Find(u).ancestor := u;
     u.colour := black;
     <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> v such that {u,v} <span class="hljs-keyword">in</span> P <span class="hljs-keyword">do</span>
         <span class="hljs-keyword">if</span> v.colour == black
             print <span class="hljs-string">"Tarjan's Lowest Common Ancestor of "</span> + u +
                   <span class="hljs-string">" and "</span> + v + <span class="hljs-string">" is "</span> + Find(v).ancestor + <span class="hljs-string">"."</span>;
</code></pre><blockquote>
<p>TODO refactor add comments</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-comment">// </span>
<span class="hljs-comment">// 1471. Tree</span>
<span class="hljs-comment">// http://acm.timus.ru/problem.aspx?space=1&amp;num=1471</span>
<span class="hljs-comment">// Time limit: 2.0 second</span>
<span class="hljs-comment">// Memory limit: 64 MB</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// A weighted tree is given. You must find the distance between two given nodes.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Input</span>
<span class="hljs-comment">// The first line contains the number of nodes of the tree n (1 ≤ n ≤ 50000).</span>
<span class="hljs-comment">// The nodes are numbered from 0 to n – 1.</span>
<span class="hljs-comment">// Each of the next n – 1 lines contains three integers u, v, w,</span>
<span class="hljs-comment">// which correspond to an edge with weight w (0 ≤ w ≤ 1000) connecting nodes u and v.</span>
<span class="hljs-comment">// The next line contains the number of queries m (1 ≤ m ≤ 75000).</span>
<span class="hljs-comment">// In each of the next m lines there are two integers.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Output</span>
<span class="hljs-comment">// For each range_minimum_query, output the distance between the nodes with the given numbers.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Sample</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// input</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 1 0 1</span>
<span class="hljs-comment">// 2 0 1</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 0 1</span>
<span class="hljs-comment">// 0 2</span>
<span class="hljs-comment">// 1 2</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// output</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 2</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXHHH 50003</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXJJJ 75005</span>

<span class="hljs-keyword">struct</span> Node {
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; next; <span class="hljs-comment">// edge list</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dist; <span class="hljs-comment">// edge length</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; query; <span class="hljs-comment">// that node of a query</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; lca; <span class="hljs-comment">// lca of this and that node</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; q_i; <span class="hljs-comment">// index of query in offline query array</span>
};

Node g[MAXHHH];
<span class="hljs-keyword">int</span> n, m;

<span class="hljs-keyword">int</span> father[MAXHHH];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{ <span class="hljs-comment">// find-union set </span>
    <span class="hljs-keyword">if</span> (father[x] == x)
        <span class="hljs-keyword">return</span> x;
    <span class="hljs-keyword">return</span> father[x] = find(father[x]);
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeFirstInToSecond</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{ <span class="hljs-comment">// find-union set</span>
    father[find(x)] = find(y);
}

pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; q[MAXJJJ]; <span class="hljs-comment">// query: node a, b</span>
pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; q_ans[MAXJJJ]; <span class="hljs-comment">// record answer's location, first = node index, second = answer index</span>
<span class="hljs-keyword">int</span> came[MAXHHH];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan_lca_dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
    <span class="hljs-comment">// process cur node and all its sub-tree</span>
    <span class="hljs-comment">// process all query related to this node and nodes in sub-tree</span>
    came[cur] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].next.size(); i++) {
        <span class="hljs-keyword">int</span> next = g[cur].next[i];
        <span class="hljs-keyword">if</span> (came[next] == <span class="hljs-number">1</span>) <span class="hljs-comment">// don't go back, it is dfs</span>
            <span class="hljs-keyword">continue</span>;

        tarjan_lca_dfs(next); <span class="hljs-comment">// process sub-tree</span>
        mergeFirstInToSecond(cur, next); <span class="hljs-comment">// order matters</span>
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].query.size(); i++) {
        <span class="hljs-keyword">int</span> that = g[cur].query[i];
        <span class="hljs-keyword">if</span> (came[that] == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">continue</span>;

        <span class="hljs-comment">// lca must be father[that] because this comes from father[that]</span>
        <span class="hljs-comment">// and father[that] haven't merge with father[father[that]]</span>
        g[cur].lca[i] = find(that);
        q_ans[g[cur].q_i[i]] = make_pair(cur, i); <span class="hljs-comment">// record position for later usage</span>
    }
}

<span class="hljs-keyword">int</span> root_dis[MAXHHH];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].next.size(); i++) {
        <span class="hljs-keyword">int</span> next = g[cur].next[i];
        <span class="hljs-keyword">if</span> (root_dis[next] != <span class="hljs-number">-1</span>)
            <span class="hljs-keyword">continue</span>;

        root_dis[next] = g[cur].dist[i] + root_dis[cur];
        dfs(next);
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; n;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> a, b, c;
        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        g[a].next.push_back(b);
        g[a].dist.push_back(c);
        g[b].next.push_back(a);
        g[b].dist.push_back(c);
        father[i] = i;
    }
    <span class="hljs-built_in">cin</span> &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) { <span class="hljs-comment">// offline</span>
        <span class="hljs-built_in">cin</span> &gt;&gt; q[i].first &gt;&gt; q[i].second;
        g[q[i].first].query.push_back(q[i].second);
        g[q[i].first].lca.push_back(<span class="hljs-number">-1</span>);
        g[q[i].first].q_i.push_back(i);
        g[q[i].second].query.push_back(q[i].first);
        g[q[i].second].lca.push_back(<span class="hljs-number">-1</span>);
        g[q[i].second].q_i.push_back(i);
        q_ans[i] = make_pair(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);
    }

    <span class="hljs-built_in">memset</span>(root_dis, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(root_dis)); root_dis[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    dfs(<span class="hljs-number">0</span>);
    tarjan_lca_dfs(<span class="hljs-number">0</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
        <span class="hljs-keyword">int</span> lca = g[q_ans[i].first].lca[q_ans[i].second];
        <span class="hljs-keyword">int</span> ans = root_dis[q[i].first] + root_dis[q[i].second] - <span class="hljs-number">2</span> * root_dis[lca];
        <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}
</code></pre>
<h4 id="2-2-4-centroid-decomposition">2.2.4 Centroid Decomposition</h4>
<blockquote>
<p>O(NlogN)</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-comment">// </span>
<span class="hljs-comment">// https://threads-iiith.quora.com/Centroid-Decomposition-of-a-Tree</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// centroid decomposition O(NlogN)</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// codeforces 342E</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// E. Xenia and Tree</span>
<span class="hljs-comment">// time limit per test5 seconds</span>
<span class="hljs-comment">// memory limit per test256 megabytes</span>
<span class="hljs-comment">// inputstandard input</span>
<span class="hljs-comment">// outputstandard output</span>
<span class="hljs-comment">// Xenia the programmer has a tree consisting of n nodes. </span>
<span class="hljs-comment">// We will consider the tree nodes indexed from 1 to n. </span>
<span class="hljs-comment">// We will also consider the first node to be initially painted red, </span>
<span class="hljs-comment">// and the other nodes — to be painted blue.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// The distance between two tree nodes v and u is the number of edges in the shortest path between v and u.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Xenia needs to learn how to quickly execute queries of two types:</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// paint a specified blue node in red;</span>
<span class="hljs-comment">// calculate which red node is the closest to the given one and print the shortest distance to the closest red node.</span>
<span class="hljs-comment">// Your task is to write a program which will execute the described queries.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Input</span>
<span class="hljs-comment">// The first line contains two integers n and m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105) — the number of nodes in the tree and the number of queries. </span>
<span class="hljs-comment">// Next n - 1 lines contain the tree edges, the i-th line contains a pair of integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — an edge of the tree.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Next m lines contain queries. Each query is specified as a pair of integers ti, vi (1 ≤ ti ≤ 2, 1 ≤ vi ≤ n). </span>
<span class="hljs-comment">// If ti = 1, then as a reply to the query we need to paint a blue node vi in red. </span>
<span class="hljs-comment">// If ti = 2, then we should reply to the query by printing the shortest distance from some red node to node vi.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// It is guaranteed that the given graph is a tree and that all queries are correct.</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Output</span>
<span class="hljs-comment">// For each second type query print the reply in a single line.</span>
<span class="hljs-comment">// </span>

<span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;
    };

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">1</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;

    <span class="hljs-keyword">int</span> root = <span class="hljs-number">1</span>;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn, <span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>)</span> </span>{
        n = nn;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)
            g[i].clear();
        edge.clear();
        m *= <span class="hljs-number">2</span>;
        edge.reserve(m); <span class="hljs-comment">// may speedup // add_e too slow</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
        g[x].push_back(edge.size());
        edge.push_back((Edge){y});

        g[y].push_back(edge.size());
        edge.push_back((Edge){x});
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, edge[ie].to);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }

    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// --- start of centroid decomposition --- </span>
    <span class="hljs-comment">// </span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; centroid; <span class="hljs-comment">// index of upper level centroid node</span>

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; subtree_size;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; deleted;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compute_subtree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
        <span class="hljs-keyword">int</span>&amp; size = subtree_size[cur];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[cur]) {
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            <span class="hljs-keyword">int</span> nx = e.to;
            <span class="hljs-keyword">if</span> (parent[nx] == <span class="hljs-number">-1</span>) {
                parent[nx] = cur;
                size += compute_subtree(nx);
            }
        }
        <span class="hljs-keyword">return</span> size;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">centroid_decomposite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> tree_size)</span> </span>{ <span class="hljs-comment">// O(Nlog(N)) </span>
        <span class="hljs-keyword">int</span> half_size = tree_size / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">while</span> (subtree_size[cur] &lt;= half_size) <span class="hljs-comment">// go up until centroid is in subtree</span>
            cur = parent[cur];

        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">int</span> candidate = cur;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[cur]) { <span class="hljs-comment">// go down if centroid is in subtree</span>
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
                <span class="hljs-keyword">int</span> nx = e.to;
                <span class="hljs-keyword">if</span> (!deleted[nx] &amp;&amp; nx != parent[cur]) {
                    <span class="hljs-keyword">if</span> (subtree_size[nx] &gt; half_size) {
                        SHOW(cur, nx, subtree_size[nx], candidate)
                        candidate = nx;
                    }
                }
            }
            <span class="hljs-keyword">if</span> (candidate == cur)
                <span class="hljs-keyword">break</span>;
            cur = candidate;
        }

        deleted[cur] = <span class="hljs-literal">true</span>;
        centroid[cur] = from;

        <span class="hljs-keyword">int</span> temp = parent[cur];
        <span class="hljs-keyword">int</span> cur_size = subtree_size[cur];
        <span class="hljs-keyword">while</span> (!deleted[temp] &amp;&amp; temp != parent[temp]) { <span class="hljs-comment">// update all the subtree_size of parent</span>
            subtree_size[temp] -= cur_size;
            temp = parent[temp];
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[cur]) { <span class="hljs-comment">// decomposite parent and children</span>
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            <span class="hljs-keyword">int</span> nx = e.to;
            <span class="hljs-keyword">if</span> (!deleted[nx]) {
                <span class="hljs-keyword">int</span> nx_tree_size; <span class="hljs-comment">// size of next level centroid tree</span>
                <span class="hljs-keyword">if</span> (nx == parent[cur])
                    nx_tree_size = tree_size - cur_size;
                <span class="hljs-keyword">else</span>
                    nx_tree_size = subtree_size[nx];

                <span class="hljs-keyword">if</span> (nx_tree_size == <span class="hljs-number">1</span>)
                    centroid[nx] = cur; <span class="hljs-comment">// don't need to go into it</span>
                <span class="hljs-keyword">else</span>
                    centroid_decomposite(nx, cur, nx_tree_size);
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">centroid_decomposite</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>).swap(centroid);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>).swap(subtree_size); <span class="hljs-comment">// initialized each to be 1 (itself)</span>
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>).swap(parent);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>).swap(deleted);

        parent[root] = root;
        compute_subtree(root);

        centroid_decomposite(root, <span class="hljs-number">-1</span>, n);
    }
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// --- end of centroid decomposition --- </span>
    <span class="hljs-comment">// </span>
};
</code></pre>
<p>Key functions</p>
<pre><code class="lang-C++"><span class="hljs-keyword">int</span> dfs_size(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> from) {
    <span class="hljs-keyword">int</span> total = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> child : tree[cur].children) {
        <span class="hljs-keyword">if</span> (child == from) <span class="hljs-keyword">continue</span>;
        total += dfs_size(child, cur);
    }
    tree[cur].<span class="hljs-keyword">size</span> = total;
    <span class="hljs-keyword">return</span> total;
}

void find_centroid(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> from) {
    #ifdef DEBUG
        cout &lt;&lt; <span class="hljs-string">"find centroid for "</span> &lt;&lt; cur &lt;&lt; <span class="hljs-string">" from "</span> &lt;&lt; from &lt;&lt; endl;
    #endif
    <span class="hljs-comment">// SHOW(cur)</span>
    <span class="hljs-comment">// finish condition</span>
    <span class="hljs-keyword">if</span> (tree[cur].<span class="hljs-keyword">size</span> == <span class="hljs-number">1</span>) {
        tree[cur].c_parent = from;
    }
    <span class="hljs-comment">// check if current node is centroid.</span>
    <span class="hljs-keyword">int</span> max_child_size = <span class="hljs-number">0</span>, max_child;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> child : tree[cur].children) {
        <span class="hljs-comment">// if (child == from) continue;</span>
        <span class="hljs-keyword">if</span> (tree[child].c_parent != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span> (tree[child].<span class="hljs-keyword">size</span> &gt; max_child_size) {
            max_child_size = tree[child].<span class="hljs-keyword">size</span>;
            max_child = child;
        }
    }
    <span class="hljs-keyword">if</span> (max_child_size &gt; tree[cur].<span class="hljs-keyword">size</span> / <span class="hljs-number">2</span>) {
        <span class="hljs-comment">// move root</span>
        tree[max_child].<span class="hljs-keyword">size</span> = tree[cur].<span class="hljs-keyword">size</span>;
        tree[cur].<span class="hljs-keyword">size</span> -= max_child_size;
        find_centroid(max_child, from);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// cur is centroid</span>
        tree[cur].c_parent = from;
        <span class="hljs-keyword">if</span> (from == <span class="hljs-number">0</span>) ctree_root = cur;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> child : tree[cur].children) {
            <span class="hljs-comment">// if (child == from) continue;</span>
            <span class="hljs-keyword">if</span> (tree[child].c_parent != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;
            find_centroid(child, cur);
        }
    }
}

void <span class="hljs-keyword">color</span>(<span class="hljs-keyword">int</span> cur) {
    <span class="hljs-keyword">int</span> <span class="hljs-keyword">parent</span> = cur;
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">parent</span>) {
        tree[<span class="hljs-keyword">parent</span>].closest = <span class="hljs-keyword">min</span>(tree[<span class="hljs-keyword">parent</span>].closest, distance(cur, <span class="hljs-keyword">parent</span>));
        <span class="hljs-keyword">parent</span> = tree[<span class="hljs-keyword">parent</span>].c_parent;
    }
}

<span class="hljs-keyword">int</span> query(<span class="hljs-keyword">int</span> cur) {
    <span class="hljs-keyword">int</span> ans = MAX_N;
    <span class="hljs-keyword">int</span> <span class="hljs-keyword">parent</span> = cur;
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">parent</span>) {
        ans = <span class="hljs-keyword">min</span>(ans, tree[<span class="hljs-keyword">parent</span>].closest + distance(cur, <span class="hljs-keyword">parent</span>));
        <span class="hljs-keyword">parent</span> = tree[<span class="hljs-keyword">parent</span>].c_parent;
    }
    <span class="hljs-keyword">return</span> ans;
}
</code></pre>
<h3 id="2-3-trie-trie-graph-ac-automaton">2.3 Trie / Trie Graph / AC Automaton</h3>
<blockquote>
<p>O(NL+M) - NL: total len of words in dict, M: len of article</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-comment">// </span>
<span class="hljs-comment">// input: n, q, string x n, string x q</span>
<span class="hljs-comment">// output: for each query, print number of string whose prefix is the query</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Sample Input</span>
<span class="hljs-comment">// 5</span>
<span class="hljs-comment">// babaab</span>
<span class="hljs-comment">// babbbaaaa</span>
<span class="hljs-comment">// abba</span>
<span class="hljs-comment">// aaaaabaa</span>
<span class="hljs-comment">// babaababb</span>
<span class="hljs-comment">// 5</span>
<span class="hljs-comment">// babb</span>
<span class="hljs-comment">// baabaaa</span>
<span class="hljs-comment">// bab</span>
<span class="hljs-comment">// bb</span>
<span class="hljs-comment">// bbabbaab</span>
<span class="hljs-comment">// Sample Output</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 0</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 0</span>
<span class="hljs-comment">// 0</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// check if any word in dict appear in article</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Sample Input</span>
<span class="hljs-comment">// 6</span>
<span class="hljs-comment">// aaabc</span>
<span class="hljs-comment">// aaac</span>
<span class="hljs-comment">// abcc</span>
<span class="hljs-comment">// ac</span>
<span class="hljs-comment">// bcd</span>
<span class="hljs-comment">// cd</span>
<span class="hljs-comment">// aaaaaaaaaaabaaadaaac</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// Sample Output</span>
<span class="hljs-comment">// YES</span>
<span class="hljs-comment">// </span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HHH 1000002</span>
<span class="hljs-keyword">struct</span> TrieNode
{
    <span class="hljs-keyword">char</span> val; <span class="hljs-comment">// 'a' ~ 'z'</span>
    <span class="hljs-keyword">bool</span> ended; <span class="hljs-comment">// is a word ended here</span>
    <span class="hljs-keyword">int</span> count; <span class="hljs-comment">// number of word ended here</span>
    <span class="hljs-keyword">int</span> childCount; <span class="hljs-comment">// number of word contianing this prefix</span>

    <span class="hljs-keyword">int</span> next[<span class="hljs-number">26</span>]; <span class="hljs-comment">// index of child node, 'a' ~ 'z'</span>

    <span class="hljs-keyword">int</span> prev; <span class="hljs-comment">// parent node // for trie-graph</span>
    <span class="hljs-keyword">bool</span> suffixEnded;<span class="hljs-comment">// suffix node is an end // for trie-graph</span>
    <span class="hljs-keyword">int</span> suffix[<span class="hljs-number">26</span>]; <span class="hljs-comment">// suffix node // for trie-graph</span>

    TrieNode() {
        val = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(next, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(next));
        ended = <span class="hljs-literal">false</span>;
        count = <span class="hljs-number">0</span>;
        childCount = <span class="hljs-number">0</span>;

        prev = <span class="hljs-number">-1</span>;
        suffixEnded = <span class="hljs-literal">false</span>;
        <span class="hljs-built_in">memset</span>(suffix, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(suffix));
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">cerr</span> &lt;&lt;
        <span class="hljs-string">"Val: "</span> &lt;&lt; val &lt;&lt;
        <span class="hljs-string">", prev = "</span> &lt;&lt; prev &lt;&lt;
        <span class="hljs-string">", ended = "</span> &lt;&lt; ended &lt;&lt;
        <span class="hljs-string">", count = "</span> &lt;&lt; count &lt;&lt;
        <span class="hljs-string">", childCount = "</span> &lt;&lt; childCount
        &lt;&lt; <span class="hljs-string">"\n\t "</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)
            <span class="hljs-built_in">cerr</span> &lt;&lt; (<span class="hljs-keyword">char</span>)(<span class="hljs-string">'a'</span> + i) &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; next[i] &lt;&lt; <span class="hljs-string">" "</span>;
        <span class="hljs-built_in">cerr</span>
        &lt;&lt; <span class="hljs-string">"\n\tsuffix suffixEnded = "</span> &lt;&lt; suffixEnded &lt;&lt; <span class="hljs-string">"\n"</span>
        &lt;&lt; <span class="hljs-string">"\t "</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)
            <span class="hljs-built_in">cerr</span> &lt;&lt; (<span class="hljs-keyword">char</span>)(<span class="hljs-string">'a'</span> + i) &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; suffix[i] &lt;&lt; <span class="hljs-string">" "</span>;
        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
};

<span class="hljs-keyword">struct</span> Trie
{
    TrieNode node[HHH];
    <span class="hljs-keyword">int</span> size; <span class="hljs-comment">// the index of last node</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s)</span> </span>{ <span class="hljs-comment">// return index of new node</span>
        <span class="hljs-keyword">int</span> preIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) {
            TrieNode&amp; pre = node[preIndex];
            <span class="hljs-keyword">int</span>&amp; curIndex = pre.next[s[i] - <span class="hljs-string">'a'</span>];
            <span class="hljs-keyword">if</span> (curIndex == <span class="hljs-number">-1</span>) {
                size++;
                curIndex = size;
            }
            TrieNode&amp; cur = node[curIndex];
            cur.val = s[i];
            cur.childCount++;

            preIndex = curIndex;
        }
        node[preIndex].ended = <span class="hljs-literal">true</span>;
        node[preIndex].count++;
        node[<span class="hljs-number">0</span>].childCount++;
        <span class="hljs-keyword">return</span> preIndex;
    };

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildSuffix</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) {
            <span class="hljs-keyword">int</span>&amp; next = node[<span class="hljs-number">0</span>].next[i];
            <span class="hljs-keyword">int</span>&amp; suffix = node[<span class="hljs-number">0</span>].suffix[i];

            suffix = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (next == <span class="hljs-number">-1</span>)
                next = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">else</span> {
                q.push(next);
                node[next].prev = <span class="hljs-number">0</span>;
            }
        }

        <span class="hljs-keyword">while</span> (q.size()) {
            <span class="hljs-keyword">int</span> cur = q.front(); q.pop();
            <span class="hljs-keyword">int</span> prev = node[cur].prev;
            <span class="hljs-keyword">int</span> prevSuffix = node[prev].suffix[node[cur].val - <span class="hljs-string">'a'</span>];
            <span class="hljs-keyword">if</span> (node[prevSuffix].ended)
                node[cur].suffixEnded = <span class="hljs-literal">true</span>;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) {
                <span class="hljs-keyword">int</span>&amp; next = node[cur].next[i];
                <span class="hljs-keyword">int</span>&amp; suffix = node[cur].suffix[i];

                suffix = node[prevSuffix].next[i];
                <span class="hljs-keyword">if</span> (next == <span class="hljs-number">-1</span>)
                    next = suffix;
                <span class="hljs-keyword">else</span> {
                    q.push(next);
                    node[next].prev = cur;
                }
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s)</span> </span>{ <span class="hljs-comment">// get index of node</span>
        <span class="hljs-keyword">int</span> preIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() &amp;&amp; preIndex != <span class="hljs-number">-1</span>; i++)
            preIndex = node[preIndex].next[s[i] - <span class="hljs-string">'a'</span>];
        <span class="hljs-keyword">return</span> preIndex;
    };

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>; i &lt; s.length(); i++) {
            cur = node[cur].next[s[i] - <span class="hljs-string">'a'</span>];
            <span class="hljs-keyword">if</span> (node[cur].ended || node[cur].suffixEnded)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    Trie() {
        size = <span class="hljs-number">0</span>;
    };

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= size; i++) {
            show_A(i);
            node[i].show();
        }
    }
};

<span class="hljs-keyword">int</span> n, q;
Trie t;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; n;

    <span class="hljs-built_in">string</span> temp;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-built_in">cin</span> &gt;&gt; temp;
        t.add(temp);
    }

    <span class="hljs-built_in">cin</span> &gt;&gt; q;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) {
        <span class="hljs-built_in">cin</span> &gt;&gt; temp;
        <span class="hljs-keyword">int</span> index = t.get(temp);

        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>)
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// not found </span>
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">cout</span> &lt;&lt; t.node[index].childCount &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// found</span>
    }


    <span class="hljs-comment">// check if any word in dict appear in article</span>
    t.buildSuffix();

    <span class="hljs-built_in">string</span> article; <span class="hljs-built_in">cin</span> &gt;&gt; article;
    <span class="hljs-keyword">if</span> (t.match(article))
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"YES"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"NO"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<pre><code class="lang-c++"><span class="hljs-comment">// http://blog.csdn.net/u010700335/article/details/38930175</span>

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">26</span>;<span class="hljs-comment">//26个小写字母或者大写字母，再加上0~9就是72</span>
<span class="hljs-comment">//定义字典树结构体</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> Trie
{
    <span class="hljs-keyword">bool</span> flag;<span class="hljs-comment">//从根到此是否为一个单词</span>
    Trie *next[maxn];<span class="hljs-comment">//有多少个分支</span>
}Trie;
<span class="hljs-comment">// 声明一个根，不含任何信息</span>
Trie *root;
<span class="hljs-comment">//初始化该根</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trie_init</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> i;
    root = <span class="hljs-keyword">new</span> Trie;
    root-&gt;flag = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxn;i++)
        root-&gt;next[i] = <span class="hljs-literal">NULL</span>;
}
<span class="hljs-comment">// 插入一个字符串</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trie_insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *word)</span>
</span>{
    <span class="hljs-comment">//int i = 0;</span>
    <span class="hljs-comment">//while(word[i] != '\0')</span>
    Trie *tem = root;
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span>(*word != <span class="hljs-string">'\0'</span>)
    {
       <span class="hljs-comment">// cout &lt;&lt; "root**" &lt;&lt; tem-&gt;next[0];</span>
        <span class="hljs-keyword">if</span>(tem-&gt;next[*word-<span class="hljs-string">'a'</span>] == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">// 为空才建立</span>
        {
            Trie *cur = <span class="hljs-keyword">new</span> Trie;
            cur-&gt;flag = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxn;i++)
                cur-&gt;next[i] = <span class="hljs-literal">NULL</span>;
            tem-&gt;next[*word-<span class="hljs-string">'a'</span>] = cur;
        }
        tem = tem-&gt;next[*word-<span class="hljs-string">'a'</span>];
        <span class="hljs-comment">//cout &lt;&lt; *word &lt;&lt; "**";</span>
        word++;
    }
    tem-&gt;flag = <span class="hljs-literal">true</span>;<span class="hljs-comment">//插入一个完整的单词</span>
}
<span class="hljs-comment">// 查找一个字符串</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">trie_search</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *word)</span>
</span>{
    Trie *tem = root;
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; word[i]!=<span class="hljs-string">'\0'</span>; i++)
    {
        <span class="hljs-keyword">if</span>(tem==<span class="hljs-literal">NULL</span> || tem-&gt;next[word[i]-<span class="hljs-string">'a'</span>]==<span class="hljs-literal">NULL</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        tem = tem-&gt;next[word[i]-<span class="hljs-string">'a'</span>];
    }
    <span class="hljs-keyword">return</span> tem-&gt;flag;
}


<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trie_del</span><span class="hljs-params">(Trie *cur)</span>
</span>{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxn;i++)
    {
        <span class="hljs-keyword">if</span>(cur-&gt;next[i] != <span class="hljs-literal">NULL</span>)
            trie_del(cur-&gt;next[i]);
    }
    <span class="hljs-keyword">delete</span> cur;
}


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> i,n;
    <span class="hljs-keyword">char</span> tmp[<span class="hljs-number">50</span>];
    trie_init();
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"请输入初始化字典树的字符串(字符0结束）："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; tmp)
    {
        <span class="hljs-comment">//cout &lt;&lt; tmp &lt;&lt; endl;</span>
        <span class="hljs-keyword">if</span>(tmp[<span class="hljs-number">0</span>] == <span class="hljs-string">'0'</span> &amp;&amp; tmp[<span class="hljs-number">1</span>] ==<span class="hljs-string">'\0'</span>) <span class="hljs-keyword">break</span>;
        trie_insert(tmp);
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"请输入要查找的字符串："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; tmp)
    {
        <span class="hljs-comment">//cout &lt;&lt; tmp &lt;&lt; endl;</span>
        <span class="hljs-keyword">if</span>(tmp[<span class="hljs-number">0</span>] == <span class="hljs-string">'0'</span> &amp;&amp; tmp[<span class="hljs-number">1</span>] ==<span class="hljs-string">'\0'</span>) <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">if</span>(trie_search(tmp))
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"查找成功！再次输入查找，字符0结束查找："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"查找失败！再次输入查找，字符0结束查找："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 id="2-4-suffix-tree">2.4 Suffix Tree</h3>
<h3 id="2-5-suffix-array">2.5 Suffix Array</h3>
<pre><code class="lang-c++"><span class="hljs-selector-tag">int</span> <span class="hljs-selector-tag">main</span>() {
    <span class="hljs-selector-tag">cin</span> &gt;&gt; <span class="hljs-selector-tag">s</span>;
    <span class="hljs-selector-tag">build_suffix_array</span>();
    <span class="hljs-selector-tag">compute_lcp</span>();
    <span class="hljs-selector-tag">longest_repeated_substring</span>();

    <span class="hljs-selector-tag">longest_common_substring</span>(<span class="hljs-string">"GATAGACA"</span>, <span class="hljs-string">"CATA"</span>);
}
</code></pre>
<h4 id="2-5-1-build-suffix-array">2.5.1 Build Suffix Array</h4>
<blockquote>
<p>O(nlog(n))</p>
<p>reference: Competitve Programming</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HH 100002</span>

<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> base_char = <span class="hljs-string">'.'</span>;
<span class="hljs-built_in">string</span> s;
<span class="hljs-keyword">int</span> rank_array[HH];
<span class="hljs-keyword">int</span> rank_array_temp[HH];
<span class="hljs-keyword">int</span> suffix_array[HH];
<span class="hljs-keyword">int</span> suffix_array_temp[HH];
<span class="hljs-keyword">int</span> counter[HH];

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">counting_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-built_in">memset</span>(counter, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(counter));

    <span class="hljs-keyword">int</span> len = s.length();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
        <span class="hljs-comment">// i will cover all suffix_array[i]</span>
        <span class="hljs-comment">// so i + k will cover all suffix_array[i] + k</span>
        <span class="hljs-comment">// so just use i + k instead of suffix_array[i] for counting</span>
        <span class="hljs-comment">// the order is not important anyway</span>
        <span class="hljs-keyword">int</span> old_rank = i + k &lt; len ? rank_array[i + k] : <span class="hljs-number">0</span>;
        counter[old_rank]++;
    }

    <span class="hljs-keyword">int</span> accu = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> largest_possible_value = max(<span class="hljs-number">256</span>, len); <span class="hljs-comment">// initial rank is based on ascii value</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; largest_possible_value; i++) {
        <span class="hljs-comment">// counter[x]: 2, 1, 0, 0, 2, 0</span>
        <span class="hljs-comment">// become    : 0, 2, 3, 3, 3, 5</span>
        <span class="hljs-comment">// which stands for the new rank with that old rank x</span>
        <span class="hljs-comment">// the meaning changes here !!</span>
        <span class="hljs-keyword">int</span> count_temp = counter[i];
        counter[i] = accu;
        accu += count_temp;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
        <span class="hljs-comment">// for each suffix_array[i]</span>
        <span class="hljs-comment">// get its new rank using its old rank suffix_array[i] + k</span>
        <span class="hljs-comment">// above if i + k &gt;= n, we change it to 0</span>
        <span class="hljs-comment">// the same here</span>
        <span class="hljs-keyword">int</span> old_rank = suffix_array[i] + k &lt; len ? rank_array[suffix_array[i] + k] : <span class="hljs-number">0</span>;
        <span class="hljs-comment">// value of counter[old_rank] is the new rank</span>
        <span class="hljs-comment">// put suffix_array[i] to its new position == new rank</span>
        <span class="hljs-comment">// why ++ ? suppose</span>
        <span class="hljs-comment">// counter[x]: 0, 2, 3, 3, 3, 5</span>
        <span class="hljs-comment">// gradually it become</span>
        <span class="hljs-comment">// counter[x]: 1, 2, 3, 3, 3, 5</span>
        <span class="hljs-comment">// counter[x]: 2, 2, 3, 3, 3, 5</span>
        <span class="hljs-comment">// counter[x]: 2, 3, 3, 3, 3, 5</span>
        <span class="hljs-comment">// ... thus assign each suffix_array[x] distinguished value</span>
        <span class="hljs-comment">// even if there keys are the same</span>
        <span class="hljs-comment">// but relation between different key keeps</span>
        <span class="hljs-comment">// why assign distinguished rank ?</span>
        <span class="hljs-comment">// of course... otherwise multiple suffix_array[i] (different suffix) go to same suffix_array[x]</span>
        <span class="hljs-comment">// the rank of them are still kept in the rank_array[x]</span>
        <span class="hljs-comment">// later will compress the rank </span>
        <span class="hljs-comment">// keeping the order between those with same key</span>
        <span class="hljs-comment">// eventually all the rank will be different</span>
        suffix_array_temp[counter[old_rank]++] = suffix_array[i];
    }
    <span class="hljs-built_in">memcpy</span>(suffix_array, suffix_array_temp, <span class="hljs-keyword">sizeof</span>(suffix_array));
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_suffix_array</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> len = s.length();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        rank_array[i] = s[i] - base_char; <span class="hljs-comment">// initial rank // based on 1st char</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        suffix_array[i] = i; <span class="hljs-comment">// initialize</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; len; k &lt;&lt;= <span class="hljs-number">1</span>) {
        <span class="hljs-comment">// sort based on 2^i portion</span>
        <span class="hljs-comment">// finally all will be sorted</span>

        <span class="hljs-comment">// [0, i + k) is first part</span>
        <span class="hljs-comment">// [i + k, i + k + k) is second part</span>
        <span class="hljs-comment">// sort second part then first part</span>
        <span class="hljs-comment">// leading to a stable_sort (?)</span>
        <span class="hljs-comment">// use [i + k, i + k + k) as key first</span>
        <span class="hljs-comment">// then use [0, i + k) as key</span>
        counting_sort(k);
        counting_sort(<span class="hljs-number">0</span>);

        <span class="hljs-comment">// after spread suffix with same rank into differnt suffix_array[x] slot (consecutive)</span>
        <span class="hljs-comment">// compress the rank_array</span>
        <span class="hljs-comment">// so that suffix with same second part [i + k, i + k + k) (which is the rank...)</span>
        <span class="hljs-comment">// have same rank...</span>
        <span class="hljs-keyword">int</span> rank = <span class="hljs-number">0</span>;
        rank_array_temp[suffix_array[<span class="hljs-number">0</span>]] = rank;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) {
            <span class="hljs-keyword">if</span> (rank_array[suffix_array[i - <span class="hljs-number">1</span>]] != rank_array[suffix_array[i]]
                ||
                rank_array[suffix_array[i] + k] != rank_array[suffix_array[i - <span class="hljs-number">1</span>] + k])
                rank++;
            rank_array_temp[suffix_array[i]] = rank;
        }
        <span class="hljs-built_in">memcpy</span>(rank_array, rank_array_temp, <span class="hljs-keyword">sizeof</span>(rank_array));
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">", suffix "</span> &lt;&lt; suffix_array[i] &lt;&lt; <span class="hljs-string">" : "</span> &lt;&lt; s.substr(suffix_array[i], s.length() - suffix_array[i]) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h4 id="2-5-2-pattern-matching">2.5.2 Pattern Matching</h4>
<blockquote>
<p>O(mlog(n))</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_pattern</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; pattern)</span> </span>{
    <span class="hljs-comment">// binary search upper bound &amp; lower bound (?) in the suffix array</span>
    <span class="hljs-comment">// to get a matched range</span>
    <span class="hljs-comment">// let m = pattern.length()</span>
    <span class="hljs-comment">// let n = s.length()</span>
    <span class="hljs-comment">// time complexity: O(mlog(n))</span>
}
</code></pre>
<h4 id="2-5-3-longest-common-prefix">2.5.3 Longest Common Prefix</h4>
<blockquote>
<p>length of common prefix between suffix_array[i-1] and suffix_array[i]</p>
<p>let n = s.length()</p>
<p>O(n)</p>
</blockquote>
<pre><code class="lang-c++">
<span class="hljs-comment">//</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-comment">//</span>

<span class="hljs-keyword">int</span> longest_common_prefix[HH]; <span class="hljs-comment">// lcp[i] = length of common prefix between sa[i-1] and sa[i]</span>
<span class="hljs-keyword">int</span> phi[HH]; <span class="hljs-comment">// phi[sa[i]] = sa[i-1] // naming ? // useless when built</span>
<span class="hljs-keyword">int</span> permuted_lcp[HH]; <span class="hljs-comment">// useless when built temp for lcp</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">compute_lcp</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// theorem: number of increase/decrese on cur_lcp is O(len)</span>
    <span class="hljs-comment">// so time complexity: O(len) for computing lcp</span>
    <span class="hljs-keyword">int</span> len = s.length();
    phi[suffix_array[<span class="hljs-number">0</span>]] = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)
        phi[suffix_array[i]] = suffix_array[i - <span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, cur_lcp = <span class="hljs-number">0</span>; i &lt; len; i++) {
        <span class="hljs-keyword">if</span> (phi[i] == <span class="hljs-number">0</span>)
            permuted_lcp[i] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">while</span> (s[i + cur_lcp] == s[phi[i] + cur_lcp])
                cur_lcp++;
            permuted_lcp[i] = cur_lcp;
            cur_lcp = max(cur_lcp - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
        }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        longest_common_prefix[i] = permuted_lcp[suffix_array[i]];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">", suffix "</span> &lt;&lt; suffix_array[i] &lt;&lt; <span class="hljs-string">" (lcp: "</span> &lt;&lt; longest_common_prefix[i] &lt;&lt; <span class="hljs-string">") : "</span> &lt;&lt; s.substr(suffix_array[i], s.length() - suffix_array[i]) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h4 id="2-5-4-longest-repeated-substring">2.5.4 Longest Repeated Substring</h4>
<blockquote>
<p>let n = s.length()</p>
<p>O(n)</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">longest_repeated_substring</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> len = s.length();
    <span class="hljs-keyword">int</span> max_repeated = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> i_max = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
        <span class="hljs-keyword">if</span> (longest_common_prefix[i] &gt; max_repeated) {
            max_repeated = longest_common_prefix[i];
            i_max = i;
        }
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"longest repeated substring: "</span> &lt;&lt; s.substr(suffix_array[i_max], max_repeated) &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h4 id="2-5-5-longest-common-substring">2.5.5 Longest Common Substring</h4>
<blockquote>
<p>string a, b (also applies to multiple strings)</p>
<p>construct Suffix Array of a.b &amp; find Longest Common Prefix</p>
<p>let n = max(a.length(), b.length())</p>
<p>O(nlog(n) + n)</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">longest_common_substring</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; b)</span> </span>{
    s = a + base_char + b;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"concatenated string: "</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;

    build_suffix_array();
    compute_lcp();

    <span class="hljs-keyword">int</span> len = s.length();
    <span class="hljs-keyword">int</span> max_common = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> i_max = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) {
        <span class="hljs-keyword">int</span> cur_lcp = longest_common_prefix[i];
        <span class="hljs-keyword">if</span> (cur_lcp &gt; max_common) {
            <span class="hljs-keyword">if</span> ((suffix_array[i] &lt; a.length()) ^ (suffix_array[i - <span class="hljs-number">1</span>] &lt; a.length())) {
                max_common = cur_lcp;
                i_max = i;
            }
        }
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"longest common prefix: "</span> &lt;&lt; s.substr(suffix_array[i_max], max_common) &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h3 id="2-6-binary-indexed-tree">2.6 Binary Indexed Tree</h3>
<blockquote>
<p>Binary Indexed Tree</p>
<p>O(logN) to query and update SUM(a[1]~a[i])</p>
</blockquote>
<pre><code class="lang-C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_INDEX nnn</span>

<span class="hljs-keyword">int</span> tree[MAX_INDEX + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 1 &lt;= I &lt;= MAX_INDEX</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">low_bit</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> i</span>) </span>{
    <span class="hljs-keyword">return</span> i &amp; -i;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> i</span>) </span>{
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (; i &gt; <span class="hljs-number">0</span>; i -= low_bit(i))
        ans += tree[i];
    <span class="hljs-keyword">return</span> ans;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span></span>) </span>{
    <span class="hljs-keyword">for</span> (; i &lt;= MAX_INDEX; i += low_bit(i))
        tree[i] += <span class="hljs-keyword">value</span>;
}
</code></pre>
<blockquote>
<p>修改区间+查询点，</p>
<p>【1】修改操作：将A[l..r]之间的全部元素值加上c；</p>
<p>【2】求和操作：求此时A[x]的值。</p>
<p>这个模型中需要设置一个辅助数组B：B[i]表示A[1..i]到目前为止共被整体加了多少</p>
</blockquote>
<pre><code class="lang-C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INTERVAL_LIMIT 100005</span>

<span class="hljs-keyword">int</span> tree_add_i_n[INTERVAL_LIMIT];

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">low_bit</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> i</span>) </span>{
    <span class="hljs-keyword">return</span> i &amp; -i;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>* tree, <span class="hljs-keyword">int</span> UP_LIMIT</span>) </span>{
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (; i &gt; <span class="hljs-number">0</span>; i -= low_bit(i))
        ans += tree[i];
    <span class="hljs-keyword">return</span> ans;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>, <span class="hljs-keyword">int</span>* tree, <span class="hljs-keyword">int</span> UP_LIMIT</span>) </span>{
    <span class="hljs-keyword">for</span> (; i &lt;= UP_LIMIT; i += low_bit(i))
        tree[i] += <span class="hljs-keyword">value</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
    memset(tree_add_in, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(tree_add_in));
    insert(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, tree_add_in, INTERVAL_LIMIT);
    insert(<span class="hljs-number">5</span>, <span class="hljs-number">-1</span>, tree_add_in, INTERVAL_LIMIT);
    insert(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, tree_add_in, INTERVAL_LIMIT);
    insert(<span class="hljs-number">6</span>, <span class="hljs-number">-2</span>, tree_add_in, INTERVAL_LIMIT);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">7</span>; i++)
        SHOW_B(i, query(i, tree_add_in, INTERVAL_LIMIT));
}
</code></pre>
<blockquote>
<p>修改区间+查询区间</p>
<p>b[i]: add b[i] to a[i], a[i+1], ..., a[n]</p>
<p>so</p>
<p>sigma(i): a[1] + a[2] + ... + a[i]</p>
<p>sigma(i) = ib[1] + (i-1)b[2] + ... + 2b[i-1] + b[i]</p>
<p>sigma(i) = (i+1){b[1] + b[2] + ... + b[i]} - {b[1] + 2b[2] + ... + ib[i]}</p>
<p>so use one more tree c[i]</p>
<p>c[i]: 1b[1] + 2b[2] + ... + ib[i]</p>
</blockquote>
<h3 id="2-7-segment-tree">2.7 Segment Tree</h3>
<h4 id="2-7-0-range-update-range-query">2.7.0 Range Update + Range Query</h4>
<blockquote>
<p>with lazy propagation</p>
<p>build O(N)</p>
<p>query O(log(N))</p>
<p>update O(log(N))</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-comment">// </span>
<span class="hljs-comment">// CodeForces 243D    Cubes</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// dynamic programming + segment tree + math - O(N*N*log(N)) - not straightforward</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// struct SegmentTree is slow, use with caution</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// </span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span>
<span class="hljs-comment">// #include &lt;unordered_set&gt;</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span>
<span class="hljs-comment">// #include &lt;unordered_map&gt;</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SHOW(...) {;}</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REACH_HERE {;}</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PRINT(s, ...) {;}</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PRINTLN(s, ...) {;}</span>

<span class="hljs-comment">// #undef HHHDEBUG</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HHHDEBUG</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"template.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">struct</span> SegmentTree {
    <span class="hljs-keyword">struct</span> Op { <span class="hljs-comment">// store lazy operation</span>
        <span class="hljs-keyword">int</span> h;
    };
    <span class="hljs-keyword">struct</span> Node {
        <span class="hljs-keyword">int</span> l; <span class="hljs-comment">// [l, ]</span>
        <span class="hljs-keyword">int</span> r; <span class="hljs-comment">// [, r]</span>

        <span class="hljs-keyword">int</span> h; <span class="hljs-comment">// value</span>

        <span class="hljs-keyword">bool</span> lazy;
        Op op;
    };

    <span class="hljs-built_in">vector</span>&lt;Node&gt; node;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{ <span class="hljs-comment">// [l, r]</span>
        <span class="hljs-keyword">int</span> tree_range = r - l + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (tree_range &lt;= <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> ;

        <span class="hljs-keyword">int</span> tree_size = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (tree_size &lt;= tree_range)
            tree_size &lt;&lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (__builtin_popcount(tree_range) != <span class="hljs-number">1</span>) <span class="hljs-comment">// count number of '1' bits</span>
            tree_size &lt;&lt;= <span class="hljs-number">1</span>;

        node.resize(tree_size); <span class="hljs-comment">// (tree_range, tree_size): (001001, 100000) (001000, 010000)</span>

        Node&amp; root = node[<span class="hljs-number">1</span>];
        root.l = l, root.r = r;
        root.h = root.op.h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; node.size(); i++) {
            Node&amp; cur = node[i];
            cur.h = <span class="hljs-number">0</span>;

            <span class="hljs-keyword">const</span> Node&amp; par = node[i / <span class="hljs-number">2</span>]; <span class="hljs-comment">// parent node</span>
            <span class="hljs-keyword">if</span> (par.l == par.r) <span class="hljs-comment">// if parent is end node, skip</span>
                cur.l = cur.r = <span class="hljs-number">-1</span>;
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">int</span> m = (par.l + par.r) / <span class="hljs-number">2</span>;
                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>)
                    cur.l = m + <span class="hljs-number">1</span>, cur.r = par.r;
                <span class="hljs-keyword">else</span>
                    cur.l = par.l, cur.r = m;
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        SHOW(<span class="hljs-string">"SegmentTree NAME"</span>)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; node.size(); i++) {
            Node&amp; cur = node[i];
            <span class="hljs-keyword">if</span> (cur.l == <span class="hljs-number">-1</span> &amp;&amp; cur.r == <span class="hljs-number">-1</span>)
                <span class="hljs-keyword">continue</span>;
            PRINTLN(<span class="hljs-string">"(%2d) [%2d,%2d] val: %d"</span>, i, cur.l, cur.r, cur.internal)
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xl, <span class="hljs-keyword">int</span> xr, <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>)</span> </span>{ <span class="hljs-comment">// query [xl, xr]</span>
        Node&amp; cur = node[i];
        <span class="hljs-keyword">if</span> (cur.l == cur.r) <span class="hljs-comment">// if end node</span>
            <span class="hljs-keyword">return</span> cur.h;

        <span class="hljs-keyword">if</span> (xl &lt;= cur.l &amp;&amp; cur.r &lt;= xr) <span class="hljs-comment">// if query cover the node</span>
            <span class="hljs-keyword">return</span> cur.h;

        <span class="hljs-keyword">int</span> lci = i * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">const</span> Node&amp; lc = node[lci];
        <span class="hljs-keyword">int</span> rci = lci + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">const</span> Node&amp; rc = node[rci];
        <span class="hljs-keyword">if</span> (cur.lazy) { <span class="hljs-comment">// if have lazy operation, push down</span>
            update(lc.l, lc.r, cur.op.h, lci);
            update(rc.l, rc.r, cur.op.h, rci);
            cur.lazy = <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">int</span> ret = INT_MAX;
        <span class="hljs-keyword">if</span> (xl &lt;= lc.r) { <span class="hljs-comment">// if query cover left child</span>
            <span class="hljs-keyword">int</span> temp = query(xl, xr, lci);
            <span class="hljs-keyword">if</span> (ret &gt; temp)
                ret = temp;
        }
        <span class="hljs-keyword">if</span> (rc.l &lt;= xr) { <span class="hljs-comment">// if query cover right child</span>
            <span class="hljs-keyword">int</span> temp = query(xl, xr, rci);
            <span class="hljs-keyword">if</span> (ret &gt; temp)
                ret = temp;
        }
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xl, <span class="hljs-keyword">int</span> xr, <span class="hljs-keyword">int</span> xh, <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>)</span> </span>{ <span class="hljs-comment">// update [xl, xr] value xh</span>
        Node&amp; cur = node[i];
        <span class="hljs-keyword">if</span> (cur.l == cur.r) { <span class="hljs-comment">// if end node</span>
            <span class="hljs-keyword">if</span> (cur.h &lt; xh)
                cur.h = xh;
            <span class="hljs-keyword">return</span> ;
        }

        <span class="hljs-keyword">if</span> (xl &lt;= cur.l &amp;&amp; cur.r &lt;= xr) { <span class="hljs-comment">// if query cover the node</span>
            <span class="hljs-keyword">if</span> (cur.h &lt; xh) { <span class="hljs-comment">// update node value </span>
                cur.h = xh;
            }
            <span class="hljs-keyword">if</span> (cur.lazy) { <span class="hljs-comment">// update the lazy operation // slow if push down now</span>
                <span class="hljs-keyword">if</span> (cur.op.h &lt; xh)
                    cur.op.h = xh;
            }
            <span class="hljs-keyword">else</span> { <span class="hljs-comment">// store lazy operation</span>
                cur.op.h = xh;
                cur.lazy = <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">return</span> ;
        }

        <span class="hljs-keyword">int</span> lci = i * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">const</span> Node&amp; lc = node[lci];
        <span class="hljs-keyword">int</span> rci = lci + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">const</span> Node&amp; rc = node[rci];
        <span class="hljs-keyword">if</span> (cur.lazy) { <span class="hljs-comment">// if have lazy operation, push down</span>
            update(lc.l, lc.r, cur.op.h, lci);
            update(rc.l, rc.r, cur.op.h, rci);
            cur.lazy = <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">if</span> (xl &lt;= lc.r) <span class="hljs-comment">// if update cover left node</span>
            update(xl, xr, xh, lci);
        <span class="hljs-keyword">if</span> (rc.l &lt;= xr) <span class="hljs-comment">// if update cover right node</span>
            update(xl, xr, xh, rci);

        cur.h = min(lc.h, rc.h); <span class="hljs-comment">// reduce two children </span>
    }
};

<span class="hljs-keyword">struct</span> Hall {
    <span class="hljs-keyword">int</span> h;
    <span class="hljs-keyword">int</span> proj_index[<span class="hljs-number">2</span>];
};

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> HH = <span class="hljs-number">1002</span>;

<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">int</span> vx;
<span class="hljs-keyword">int</span> vy;
Hall hall[HH][HH];

<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">init_project</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> xx[] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>};
    <span class="hljs-keyword">int</span> yy[] = {<span class="hljs-number">1</span>, <span class="hljs-number">0</span>};
    <span class="hljs-keyword">double</span> EPS = <span class="hljs-number">1e-7</span>;

    <span class="hljs-keyword">struct</span> Proj {
        <span class="hljs-keyword">int</span> i;
        <span class="hljs-keyword">int</span> j;
        <span class="hljs-keyword">double</span> x;
        <span class="hljs-keyword">int</span> k;
    };
    <span class="hljs-built_in">vector</span>&lt;Proj&gt; projection;
    projection.reserve(n * n * <span class="hljs-number">2</span>);

    <span class="hljs-keyword">auto</span> get_x = [](<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y) -&gt; <span class="hljs-keyword">double</span> {
        <span class="hljs-keyword">return</span> vx == <span class="hljs-number">0</span> ? x : x - y / vy * vx;
    };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">2</span>; k++)
                projection.push_back((Proj){i, j, get_x(i + xx[k], j + yy[k]), k});

    sort(begin(projection), end(projection), [](<span class="hljs-keyword">const</span> Proj&amp; a, <span class="hljs-keyword">const</span> Proj&amp; b) {
        <span class="hljs-keyword">return</span> a.x &lt; b.x;
    });

    <span class="hljs-keyword">int</span> n_seg = <span class="hljs-number">0</span>;
    hall[projection[<span class="hljs-number">0</span>].i][projection[<span class="hljs-number">0</span>].j].proj_index[projection[<span class="hljs-number">0</span>].k] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; projection.size(); i++) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(projection[i].x - projection[i - <span class="hljs-number">1</span>].x) &gt; EPS)
            n_seg++;
        hall[projection[i].i][projection[i].j].proj_index[projection[i].k] = n_seg;
    }
    <span class="hljs-keyword">return</span> n_seg;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// if vy &lt; 0</span>
    <span class="hljs-comment">// flip left right</span>
    <span class="hljs-keyword">if</span> (vy &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">int</span> r = n - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (l &lt; r) {
                swap(hall[i][l].h, hall[i][r].h);
                l++;
                r--;
            }
        }
        vy = -vy;
    }

    <span class="hljs-comment">// if vx &lt;= 0</span>
    <span class="hljs-comment">// flip diagonal</span>
    <span class="hljs-keyword">if</span> (vx &lt; <span class="hljs-number">0</span> || vy == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)
                swap(hall[i][j].h, hall[j][i].h);
        swap(vx, vy);
    }

    <span class="hljs-comment">// if vy &lt; 0</span>
    <span class="hljs-comment">// flip left right</span>
    <span class="hljs-keyword">if</span> (vy &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">int</span> r = n - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (l &lt; r) {
                swap(hall[i][l].h, hall[i][r].h);
                l++;
                r--;
            }
        }
        vy = -vy;
    }
}

SegmentTree st;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d %d"</span>, &amp;n, &amp;vx, &amp;vy);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;hall[i][j].h);

    rotate();
    <span class="hljs-keyword">int</span> len = init_project();

    st.init(<span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">const</span> Hall&amp; h = hall[i][j];
            <span class="hljs-keyword">int</span> min_height = st.query(h.proj_index[<span class="hljs-number">0</span>], h.proj_index[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);
            ans += max(<span class="hljs-number">0</span>, h.h - min_height);
            st.update(h.proj_index[<span class="hljs-number">0</span>], h.proj_index[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>, h.h);
        }
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans);
}
</code></pre>
<h4 id="2-7-1-color">2.7.1 Color</h4>
<pre><code class="lang-c++">const <span class="hljs-built_in">int</span> <span class="hljs-built_in">MAX</span> = <span class="hljs-number">100000</span>;

struct node {
    <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>;
    <span class="hljs-built_in">int</span> color;
    bool cover;
};

node nodes[<span class="hljs-number">3</span>*<span class="hljs-built_in">MAX</span>];

void build_tree(<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>, <span class="hljs-built_in">int</span> u) {
    nodes[u].<span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span>;
    nodes[u].<span class="hljs-built_in">right</span> = <span class="hljs-built_in">right</span>;
    nodes[u].color = <span class="hljs-number">1</span>;
    nodes[u].cover = <span class="hljs-built_in">true</span>;
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> == <span class="hljs-built_in">right</span>) return;
    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>)/<span class="hljs-number">2</span>;
    build_tree(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">mid</span>, <span class="hljs-number">2</span>*u);
    build_tree(<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>, <span class="hljs-built_in">right</span>, <span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>);
}

void get_down(<span class="hljs-built_in">int</span> u) {
    <span class="hljs-built_in">int</span> <span class="hljs-built_in">value</span> = nodes[u].color;
    nodes[u].cover = <span class="hljs-built_in">false</span>;
    nodes[<span class="hljs-number">2</span>*u].color = <span class="hljs-built_in">value</span>;
    nodes[<span class="hljs-number">2</span>*u].cover = <span class="hljs-built_in">true</span>;
    nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].color = <span class="hljs-built_in">value</span>;
    nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].cover = <span class="hljs-built_in">true</span>;
}

void update(<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">value</span>, <span class="hljs-built_in">int</span> u) {
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt;= nodes[u].<span class="hljs-built_in">left</span> &amp;&amp; nodes[u].<span class="hljs-built_in">right</span> &lt;= <span class="hljs-built_in">right</span>) {
        nodes[u].color = <span class="hljs-built_in">value</span>;
        nodes[u].cover = <span class="hljs-built_in">true</span>;
        return;
    }
    <span class="hljs-built_in">if</span> (nodes[u].color == <span class="hljs-built_in">value</span>) return;  // optimize purpose
    //SHOW(u);
    <span class="hljs-built_in">if</span> (nodes[u].cover) get_down(u);
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt;= nodes[<span class="hljs-number">2</span>*u].<span class="hljs-built_in">right</span>) {
        update(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>, <span class="hljs-built_in">value</span>, <span class="hljs-number">2</span>*u);
    }
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">right</span> &gt;= nodes[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].<span class="hljs-built_in">left</span>) {
        update(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>, <span class="hljs-built_in">value</span>, <span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>);
    }
    nodes[u].color = nodes[<span class="hljs-number">2</span>*u].color | nodes[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].color;
}

void query(<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>, <span class="hljs-built_in">int</span> &amp;<span class="hljs-built_in">sum</span>, <span class="hljs-built_in">int</span> u) {
    <span class="hljs-built_in">if</span> (nodes[u].cover) {
        <span class="hljs-built_in">sum</span> |= nodes[u].color;
        return;
    }
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt;= nodes[u].<span class="hljs-built_in">left</span> &amp;&amp; nodes[u].<span class="hljs-built_in">right</span> &lt;= <span class="hljs-built_in">right</span>) {
        <span class="hljs-built_in">sum</span> |= nodes[u].color;
        return;
    }
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt;= nodes[<span class="hljs-number">2</span>*u].<span class="hljs-built_in">right</span>) {
        query(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>, <span class="hljs-built_in">sum</span>, <span class="hljs-number">2</span>*u);
    }
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">right</span> &gt;= nodes[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].<span class="hljs-built_in">left</span>) {
        query(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>, <span class="hljs-built_in">sum</span>, <span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>);
    }
}

// Usage
// build_tree(<span class="hljs-number">1</span>, L, <span class="hljs-number">1</span>);
// update(a, b, new_color, <span class="hljs-number">1</span>);
// query(a, b, sum_as_reference, <span class="hljs-number">1</span>);

// only for this question
<span class="hljs-built_in">int</span> bit_count(<span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>) {
    <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;
    while (<span class="hljs-built_in">sum</span>) {
        <span class="hljs-built_in">if</span> (<span class="hljs-built_in">sum</span>%<span class="hljs-number">2</span>) ans++;
        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> &gt;&gt; <span class="hljs-number">1</span>;
    }
    return ans;
}

<span class="hljs-built_in">int</span> main() {
    <span class="hljs-built_in">int</span> L, <span class="hljs-built_in">T</span>, O;
    cin &gt;&gt; L &gt;&gt; <span class="hljs-built_in">T</span> &gt;&gt; O;
    build_tree(<span class="hljs-number">1</span>, L, <span class="hljs-number">1</span>);
    while (O--) {
        <span class="hljs-built_in">char</span> op;
        <span class="hljs-built_in">int</span> a, b, c;
        cin &gt;&gt; op;
        <span class="hljs-built_in">if</span> (op == 'C') {
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            <span class="hljs-built_in">if</span> (a &gt; b) swap(a, b);
            update(a, b, <span class="hljs-number">1</span>&lt;&lt;(c-<span class="hljs-number">1</span>), <span class="hljs-number">1</span>);
        } else {
            cin &gt;&gt; a &gt;&gt; b;
            <span class="hljs-built_in">if</span> (a &gt; b) swap(a, b);
            <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;
            query(a, b, <span class="hljs-built_in">sum</span>, <span class="hljs-number">1</span>);
            cout &lt;&lt; bit_count(<span class="hljs-built_in">sum</span>) &lt;&lt; endl;
        }
    }
    return <span class="hljs-number">0</span>;
}
</code></pre>
<h4 id="2-7-2-range-sum-range-replace">2.7.2 Range Sum + Range Replace</h4>
<pre><code class="lang-c++">const <span class="hljs-built_in">int</span> <span class="hljs-built_in">MAX</span> = <span class="hljs-number">30005</span>;

struct node {
    <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>;
    long long <span class="hljs-built_in">sum</span>;
    <span class="hljs-built_in">int</span> lazy;
    bool dirty;
};

node nodes[<span class="hljs-number">4</span>*<span class="hljs-built_in">MAX</span>];

void build_tree(<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>, <span class="hljs-built_in">int</span> u) {
    nodes[u].<span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span>;
    nodes[u].<span class="hljs-built_in">right</span> = <span class="hljs-built_in">right</span>;
    nodes[u].<span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;
    nodes[u].lazy = <span class="hljs-number">0</span>;
    nodes[u].dirty = <span class="hljs-built_in">false</span>;
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> == <span class="hljs-built_in">right</span>) return;
    <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>)/<span class="hljs-number">2</span>;
    build_tree(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">mid</span>, <span class="hljs-number">2</span>*u);
    build_tree(<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>, <span class="hljs-built_in">right</span>, <span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>);
}

void get_down(<span class="hljs-built_in">int</span> u) {
    <span class="hljs-built_in">if</span> (!nodes[u].dirty) return;
    nodes[<span class="hljs-number">2</span>*u].<span class="hljs-built_in">sum</span> = (long long) nodes[u].lazy * (nodes[<span class="hljs-number">2</span>*u].<span class="hljs-built_in">right</span> - nodes[<span class="hljs-number">2</span>*u].<span class="hljs-built_in">left</span> + <span class="hljs-number">1</span>);
    // <span class="hljs-built_in">if</span> update <span class="hljs-built_in">not</span> <span class="hljs-built_in">replace</span> use +=
    nodes[<span class="hljs-number">2</span>*u].lazy = nodes[u].lazy;
    nodes[<span class="hljs-number">2</span>*u].dirty = <span class="hljs-built_in">true</span>;
    nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].<span class="hljs-built_in">sum</span> = (long long) nodes[u].lazy * (nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].<span class="hljs-built_in">right</span> - nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].<span class="hljs-built_in">left</span> + <span class="hljs-number">1</span>);
    nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].lazy = nodes[u].lazy;
    nodes[<span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>].dirty = <span class="hljs-built_in">true</span>;
    nodes[u].dirty = <span class="hljs-built_in">false</span>;
}

void update(<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">value</span>, <span class="hljs-built_in">int</span> u) {
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt;= nodes[u].<span class="hljs-built_in">left</span> &amp;&amp; nodes[u].<span class="hljs-built_in">right</span> &lt;= <span class="hljs-built_in">right</span>) {
        nodes[u].<span class="hljs-built_in">sum</span> = (long long)<span class="hljs-built_in">value</span> * (nodes[u].<span class="hljs-built_in">right</span> - nodes[u].<span class="hljs-built_in">left</span> + <span class="hljs-number">1</span>);
        // <span class="hljs-built_in">if</span> update <span class="hljs-built_in">not</span> <span class="hljs-built_in">replace</span> use +=
        nodes[u].lazy = <span class="hljs-built_in">value</span>;
        nodes[u].dirty = <span class="hljs-built_in">true</span>;
        return;
    }
    get_down(u);
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt;= nodes[<span class="hljs-number">2</span>*u].<span class="hljs-built_in">right</span>) {
        update(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>, <span class="hljs-built_in">value</span>, <span class="hljs-number">2</span>*u);
    }
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">right</span> &gt;= nodes[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].<span class="hljs-built_in">left</span>) {
        update(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>, <span class="hljs-built_in">value</span>, <span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>);
    }
    nodes[u].<span class="hljs-built_in">sum</span> = nodes[<span class="hljs-number">2</span>*u].<span class="hljs-built_in">sum</span> + nodes[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].<span class="hljs-built_in">sum</span>;
}

void query(<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>, long long &amp;<span class="hljs-built_in">sum</span>, <span class="hljs-built_in">int</span> u) {
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt;= nodes[u].<span class="hljs-built_in">left</span> &amp;&amp; nodes[u].<span class="hljs-built_in">right</span> &lt;= <span class="hljs-built_in">right</span>) {
        <span class="hljs-built_in">sum</span> += nodes[u].<span class="hljs-built_in">sum</span>;
        return;
    }
    get_down(u);
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt;= nodes[<span class="hljs-number">2</span>*u].<span class="hljs-built_in">right</span>) {
        query(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>, <span class="hljs-built_in">sum</span>, <span class="hljs-number">2</span>*u);
    }
    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">right</span> &gt;= nodes[<span class="hljs-number">2</span>*u+<span class="hljs-number">1</span>].<span class="hljs-built_in">left</span>) {
        query(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>, <span class="hljs-built_in">sum</span>, <span class="hljs-number">2</span>*u + <span class="hljs-number">1</span>);
    }
}

// Usage
// build_tree(<span class="hljs-number">1</span>, L, <span class="hljs-number">1</span>);
// update(a, b, new_value, <span class="hljs-number">1</span>);
// query(a, b, sum_as_reference, <span class="hljs-number">1</span>);
</code></pre>
<h3 id="2-8-range-minimum-query-rmq">2.8 Range Minimum Query RMQ</h3>
<pre><code class="lang-c++">struct RMQ { <span class="hljs-regexp">//</span> <span class="hljs-keyword">not</span> tested
    const static <span class="hljs-keyword">int</span> MAXLENGTH = <span class="hljs-number">2</span> * <span class="hljs-number">1</span>e5 + <span class="hljs-number">3</span>;
    const static <span class="hljs-keyword">int</span> LOG_MAXLENGTH = <span class="hljs-number">20</span>;
    <span class="hljs-keyword">int</span> rm<span class="hljs-string">q[MAXLENGTH]</span>[LOG_MAXLENGTH];

    void init(<span class="hljs-keyword">int</span>* arr, <span class="hljs-keyword">int</span> len) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
            rm<span class="hljs-string">q[i]</span>[<span class="hljs-number">0</span>] = arr[i];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; LOG_MAXLENGTH; j++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                <span class="hljs-keyword">if</span> (i + (<span class="hljs-number">1</span> &lt;&lt; j) &gt; len)
                    <span class="hljs-keyword">break</span>;
                rm<span class="hljs-string">q[i]</span>[j] = rm<span class="hljs-string">q[i]</span>[j - <span class="hljs-number">1</span>];
                rm<span class="hljs-string">q[i]</span>[j] = min(rm<span class="hljs-string">q[i]</span>[j - <span class="hljs-number">1</span>], rm<span class="hljs-string">q[i + (1 &lt;&lt; (j - 1))]</span>[j-<span class="hljs-number">1</span>]);
            }
    }

    <span class="hljs-keyword">int</span> range_minimum_query(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r) {
        <span class="hljs-keyword">if</span> (l &gt; r)
            swap(l, r);

        <span class="hljs-keyword">int</span> interval_len = r - l; <span class="hljs-regexp">//</span> less <span class="hljs-number">1</span>

        <span class="hljs-keyword">int</span> first_half = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> ((<span class="hljs-number">1</span> &lt;&lt; first_half) &lt;= interval_len)
            first_half++;
        first_half--;

        <span class="hljs-keyword">int</span> second_half = r - (<span class="hljs-number">1</span> &lt;&lt; first_half) + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> min(rm<span class="hljs-string">q[l]</span>[first_half], rm<span class="hljs-string">q[second_half]</span>[first_half]);
    }
};
</code></pre>
<h3 id="2-9-union-find-set">2.9 Union-find Set</h3>
<pre><code class="lang-C++"><span class="hljs-keyword">struct</span> UnionFindSet {
    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;
    <span class="hljs-keyword">void</span> init(<span class="hljs-keyword">int</span> nn) {
        parent.resize(nn + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parent.<span class="hljs-built_in">size</span>(); i++)
            parent[i] = i;
    }

    <span class="hljs-keyword">void</span> merge(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) {
        parent[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y);
    }
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">find</span>(<span class="hljs-keyword">int</span> x) {
        <span class="hljs-built_in">return</span> x == parent[x] ? x : parent[x] = <span class="hljs-built_in">find</span>(parent[x]);
    }
    <span class="hljs-keyword">bool</span> together(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) {
        <span class="hljs-built_in">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);
    }
};
</code></pre>
<h4 id="2-9-1-union-find-set-application">2.9.1 Union-find Set - application</h4>
<blockquote>
<p>place holder</p>
</blockquote>
<h3 id="2-10-bloom-filter-similar-">2.10 Bloom Filter (?) (Similar)</h3>
<blockquote>
<p>Can calculate hash of number sequence quickly.</p>
<p>If too slow, set REPEAT smaller. Or try again:)</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span>

<span class="hljs-keyword">struct</span> BloomFilterSimilar {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">100002</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> REPEAT = <span class="hljs-number">10</span>;

    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> hash_constant[REPEAT][MAXN];
    set&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; hash[REPEAT];

    <span class="hljs-keyword">void</span> init_hash(<span class="hljs-keyword">int</span> max_n=MAXN) {
           random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; dis(<span class="hljs-number">1</span>, ULLONG_MAX);
        <span class="hljs-built_in">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; REPEAT; i++) {
            <span class="hljs-built_in">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; max_n; j++)
                hash_constant[i][j] = dis(gen);
        }
    }

    vector&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; get_hash(<span class="hljs-keyword">int</span> val) {
        vector&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; h(REPEAT);
        <span class="hljs-built_in">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; REPEAT; i++)
            h[i] = hash_constant[i][val];
        <span class="hljs-built_in">return</span> <span class="hljs-built_in">move</span>(h);
    }

    <span class="hljs-comment">// bool exist(int val) {</span>
    <span class="hljs-comment">//     return exist(get_hash(val));</span>
    <span class="hljs-comment">// }</span>
    <span class="hljs-keyword">bool</span> exist(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&amp; h) {
        <span class="hljs-built_in">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; REPEAT; i++)
            <span class="hljs-built_in">if</span> (hash[i].<span class="hljs-built_in">find</span>(h[i]) == <span class="hljs-built_in">end</span>(hash[i]))
                <span class="hljs-built_in">return</span> false;
        <span class="hljs-built_in">return</span> true; <span class="hljs-comment">// possible False Positive</span>
    }

    <span class="hljs-comment">// void insert(int val) {</span>
    <span class="hljs-comment">//     insert(get_hash(val));</span>
    <span class="hljs-comment">// }</span>
    <span class="hljs-keyword">void</span> insert(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&amp; h) {
        <span class="hljs-built_in">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; REPEAT; i++)
            hash[i].insert(h[i]);
    }
};
</code></pre>
<h2 id="3-methodology">3. Methodology</h2>
<h3 id="3-0-greedy">3.0 Greedy</h3>
<blockquote>
<p>It&#39;s Art.</p>
</blockquote>
<h3 id="3-1-recursive">3.1 Recursive</h3>
<h4 id="3-1-1-hanoi">3.1.1 Hanoi</h4>
<pre><code class="lang-C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hanoi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> x, <span class="hljs-keyword">char</span> y, <span class="hljs-keyword">char</span> z)</span> </span>{ <span class="hljs-comment">// 将 x 上编号 1 至 n 的圆盘移到 z, y 作辅助塔</span>
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d from %c to %c\n"</span>, n, x, z); <span class="hljs-comment">// 将编号为 n 的圆盘从 x 移到 z</span>
    <span class="hljs-keyword">else</span> {
        hanoi(n<span class="hljs-number">-1</span>, x, z, y); <span class="hljs-comment">// 将 x 上编号 1 至 n-1 的圆盘移到 y, z 作辅助塔</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d from %c to %c\n"</span>, n, x, z); <span class="hljs-comment">// 将编号为 n 的圆盘从 x 移到 z</span>
        hanoi(n<span class="hljs-number">-1</span>, y, x, z); <span class="hljs-comment">// 将 y 上编号 1 至 n-1 的圆盘移到 z, x 作辅助塔</span>
    }
}
</code></pre>
<h3 id="3-2-dynamic-programming">3.2 Dynamic Programming</h3>
<h4 id="3-2-1-longest-increasing-subsequence-lis-">3.2.1 Longest Increasing Subsequence (LIS)</h4>
<blockquote>
<p>O(nlog(n))</p>
</blockquote>
<pre><code class="lang-c++">vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">sequence</span>;
vector&lt;<span class="hljs-built_in">int</span>&gt; lis(<span class="hljs-keyword">sequence</span>.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, INT_MAX); // [i]: <span class="hljs-built_in">min</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">sequence</span> that have LIS = i
for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sequence</span>.<span class="hljs-built_in">size</span>(); i++) {
    <span class="hljs-built_in">int</span> r = <span class="hljs-keyword">sequence</span>[i];
    auto ptr = lower_bound(begin(lis), <span class="hljs-keyword">end</span>(lis), r);
    *ptr = <span class="hljs-built_in">min</span>(*ptr, r);
}
</code></pre>
<h3 id="3-3-divide-and-conquer">3.3 Divide and Conquer</h3>
<h4 id="3-3-1-binary-search">3.3.1 binary search</h4>
<h3 id="3-4-search">3.4 Search</h3>
<h4 id="3-4-2-bfs">3.4.2 双向 BFS</h4>
<h4 id="3-4-3-">3.4.3 从终点开始搜</h4>
<h4 id="3-4-4-binary-increase-decrease-">3.4.4 迭代加深搜索 (binary increase/decrease)</h4>
<blockquote>
<p>placeholder</p>
</blockquote>
<h3 id="3-5-brute-force">3.5 Brute Force</h3>
<h4 id="3-5-1-">3.5.1 子集生成</h4>
<h2 id="4-string">4. String</h2>
<h3 id="4-1-kmp">4.1 KMP</h3>
<blockquote>
<p>Match pattern in a string</p>
<p>O(n) = O(len(pattern) + len(string))</p>
</blockquote>
<pre><code class="lang-C++"><span class="hljs-comment">#define HHH 10003</span>

<span class="hljs-keyword">int</span> <span class="hljs-keyword">ne</span>[HHH]; <span class="hljs-regexp">//</span> <span class="hljs-keyword">next</span>[], <span class="hljs-keyword">if</span> par[i] <span class="hljs-keyword">not</span> matched, jump to i = <span class="hljs-keyword">ne</span>[i]
<span class="hljs-keyword">int</span> kmp(string&amp; par, string&amp; ori) {
    <span class="hljs-keyword">ne</span>[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-keyword">ne</span>[<span class="hljs-number">0</span>], i = <span class="hljs-number">1</span>; i &lt; par.length(); i++) {
        <span class="hljs-keyword">while</span> (p &gt;= <span class="hljs-number">0</span> &amp;&amp; par[p+<span class="hljs-number">1</span>] != par[i])
            p = <span class="hljs-keyword">ne</span>[p];
        <span class="hljs-keyword">if</span> (par[p+<span class="hljs-number">1</span>] == par[i])
            p++;
        <span class="hljs-keyword">ne</span>[i] = p;
    }

    <span class="hljs-keyword">int</span> match = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = -<span class="hljs-number">1</span>, <span class="hljs-keyword">q</span> = <span class="hljs-number">0</span>; <span class="hljs-string">q &lt; ori.length(); q++) {
        while (p &gt;</span>= <span class="hljs-number">0</span> &amp;&amp; par[p+<span class="hljs-number">1</span>] != ori[<span class="hljs-keyword">q</span>])
            p = <span class="hljs-keyword">ne</span>[p];
        <span class="hljs-keyword">if</span> (par[p+<span class="hljs-number">1</span>] == ori[<span class="hljs-keyword">q</span>])
            p++;
        <span class="hljs-keyword">if</span> (p + <span class="hljs-number">1</span> == par.length()) { <span class="hljs-regexp">//</span> match!
            p = <span class="hljs-keyword">ne</span>[p];
            match++;
        }
    }

    <span class="hljs-keyword">return</span> match; <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> number of occurance
}

<span class="hljs-keyword">int</span> main () {
    <span class="hljs-keyword">int</span> n; cin &gt;&gt; n;
    string par, ori;
    <span class="hljs-keyword">while</span> (cin &gt;&gt; par &gt;&gt; ori)
        cout &lt;&lt; kmp(par, ori) &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 id="4-2-boyer-moore">4.2 Boyer-Moore</h3>
<h3 id="4-3-longest-palindromic-substring-manacher-s-algorithm-">4.3 Longest palindromic substring (Manacher&#39;s algorithm)</h3>
<blockquote>
<p>O(n)</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-keyword">int</span> dp[HHH];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthLongestPalindromSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s)</span> </span>{
    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(dp));
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> pivot = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> len = s.length() * <span class="hljs-number">2</span>; <span class="hljs-comment">// _s0_s1_s2 = 2 * length</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) {
        <span class="hljs-keyword">int</span> pBorder = pivot + dp[pivot];
        <span class="hljs-keyword">int</span> iBorder = i;
        <span class="hljs-keyword">if</span> (iBorder &lt; pBorder &amp;&amp; <span class="hljs-number">2</span> * pivot - i &gt; <span class="hljs-number">0</span>) {
            dp[i] = dp[<span class="hljs-number">2</span>*pivot-i];
            iBorder = min(pBorder, i + dp[i]);
        }

        <span class="hljs-keyword">if</span> (iBorder &gt;= pBorder) {
            <span class="hljs-keyword">int</span> j = iBorder + (iBorder % <span class="hljs-number">2</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>);
            <span class="hljs-keyword">for</span> (; j &lt; len &amp;&amp; <span class="hljs-number">2</span>*i-j &gt; <span class="hljs-number">0</span> &amp;&amp; s[j/<span class="hljs-number">2</span>] == s[(<span class="hljs-number">2</span>*i-j)/<span class="hljs-number">2</span>]; j += <span class="hljs-number">2</span>)
                ;
            iBorder = j - <span class="hljs-number">2</span>;
            dp[i] = iBorder - i;
            pivot = i;
        }
        ans = max(ans, dp[i] + <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">return</span> ans;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> n; <span class="hljs-built_in">cin</span> &gt;&gt; n;
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; s)
        <span class="hljs-built_in">cout</span> &lt;&lt; lengthLongestPalindromSubstring(s) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="5-graph">5. Graph</h2>
<h3 id="5-1-graph-structure">5.1 Graph Structure</h3>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> from;
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> len;
    };

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">3</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn)</span> </span>{
        n = nn;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)
            g[i].clear();
        edge.clear();
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> len)</span> </span>{
        g[x].push_back(edge.size());
        edge.push_back((Edge){x, y, len});
        g[y].push_back(edge.size());
        edge.push_back((Edge){y, x, len});
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, edge[ie].to);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }
};
</code></pre>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> Network {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> pre_edge;
        <span class="hljs-keyword">int</span> cap;
        <span class="hljs-keyword">int</span> flow;
    };

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; last;

    <span class="hljs-keyword">int</span> nv; <span class="hljs-comment">// total number of vertex, index range: [0, nv)</span>
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _nv)</span> </span>{
        nv = _nv;
        <span class="hljs-built_in">vector</span>&lt;Edge&gt;().swap(edge);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nv + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>).swap(last);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> r_cap = <span class="hljs-number">0</span>)</span> </span>{
        Edge e{y, last[x], cap, <span class="hljs-number">0</span>};
        last[x] = edge.size();
        edge.push_back(move(e));

        Edge r_e{x, last[y], r_cap, <span class="hljs-number">0</span>};
        last[y] = edge.size();
        edge.push_back(move(r_e));
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_edge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[i]; ie != <span class="hljs-number">-1</span>; ) {
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie]; 
                ie = e.pre_edge;
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (%d)%d/%d"</span>, e.to, e.flow, e.cap);
            }
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }
}
</code></pre>
<h3 id="5-2-minimium-spanning-tree">5.2 Minimium Spanning Tree</h3>
<h4 id="5-2-1-prim-s">5.2.1 Prim&#39;s</h4>
<blockquote>
<p>O((V + E)log(V))</p>
</blockquote>
<pre><code class="lang-C++"><span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> from;
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> len;
    };

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">3</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn)</span> </span>{
        n = nn;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)
            g[i].clear();
        edge.clear();
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> len)</span> </span>{
        g[x].push_back(edge.size());
        edge.push_back((Edge){x, y, len});
        g[y].push_back(edge.size());
        edge.push_back((Edge){y, x, len});
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, edge[ie].to);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }

    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// ---- start of Minimum Spanning Tree ---</span>
    <span class="hljs-comment">// </span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; added;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; mindis; <span class="hljs-comment">// little optimization</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mst</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>).swap(added);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX).swap(mindis);

        <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-keyword">const</span> Edge&amp; a, <span class="hljs-keyword">const</span> Edge&amp; b) {
            <span class="hljs-keyword">return</span> a.len &gt; b.len;
        };
        priority_queue&lt;Edge, <span class="hljs-built_in">vector</span>&lt;Edge&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; near(cmp);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[<span class="hljs-number">1</span>].size(); i++) {
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[g[<span class="hljs-number">1</span>][i]];
            near.push(e);
            mindis[e.to] = e.len; <span class="hljs-comment">// little optimization</span>
        }
        added[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">while</span> (near.size()) {
            Edge cur = near.top(); near.pop();
            added[cur.to] = <span class="hljs-literal">true</span>;
            <span class="hljs-comment">// add Edge cur</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[cur.to]) {
                <span class="hljs-keyword">const</span> Edge&amp; nxe = edge[ie];
                <span class="hljs-keyword">int</span> nx = nxe.to;
                <span class="hljs-keyword">if</span> (!added[nx]
                 &amp;&amp; mindis[nx] &gt; nxe.len) { <span class="hljs-comment">// little optimization</span>
                    mindis[nx] = nxe.len; <span class="hljs-comment">// little optimization</span>
                    near.push(nxe);
                }
            }
            <span class="hljs-keyword">while</span> (near.size() &amp;&amp; added[near.top().to])
                near.pop();
        }
        <span class="hljs-comment">// </span>
    }
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// ---- end of Minimum Spanning Tree ---</span>
    <span class="hljs-comment">// </span>
};
</code></pre>
<h4 id="5-2-2-kruskal">5.2.2 Kruskal</h4>
<blockquote>
<p>Elog(E) + Elog(V)</p>
</blockquote>
<pre><code class="lang-C++"><span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> from;
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> len;
    };

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">3</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn)</span> </span>{
        n = nn;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)
            g[i].clear();
        edge.clear();
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> len)</span> </span>{
        g[x].push_back(edge.size());
        edge.push_back((Edge){x, y, len});
        g[y].push_back(edge.size());
        edge.push_back((Edge){y, x, len});
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, edge[ie].to);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }

    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// ---- start of Minimum Spanning Tree ---</span>
    <span class="hljs-comment">// </span>
    UnionFindSet ufs;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mst</span><span class="hljs-params">()</span> </span>{
        ufs.init(n);
        <span class="hljs-built_in">vector</span>&lt;Edge&gt; eee = edge;
        sort(begin(eee), end(eee), [](<span class="hljs-keyword">const</span> Edge&amp; a, <span class="hljs-keyword">const</span> Edge&amp; b) {
            <span class="hljs-keyword">return</span> a.len &lt; b.len;
        });

        <span class="hljs-keyword">int</span> need = n - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e : eee) {
            <span class="hljs-keyword">if</span> (!ufs.together(e.from, e.to)) {
                <span class="hljs-comment">// add Edge e</span>
                ufs.merge(e.from, e.to);
                need--;
                <span class="hljs-keyword">if</span> (!need)
                    <span class="hljs-keyword">break</span>;
            }
        }
    }
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// ---- end of Minimum Spanning Tree ---</span>
    <span class="hljs-comment">// </span>
};
</code></pre>
<h3 id="5-3-shortest-path">5.3 Shortest Path</h3>
<h4 id="5-3-1-">5.3.1 任意两点</h4>
<pre><code>for (<span class="hljs-name">k</span>)
    for (<span class="hljs-name">i</span>)
        for (<span class="hljs-name">j</span>)
            d(<span class="hljs-name">i</span>, j) = min(<span class="hljs-name">d</span>(<span class="hljs-name">i</span>, j), d(<span class="hljs-name">i</span>, k) + d(<span class="hljs-name">j</span>, k))
</code></pre><h4 id="5-3-2-bellman-ford">5.3.2 Bellman–Ford</h4>
<blockquote>
<p>Bellman–Ford algorithm is O(VE).
Can be applied to situations when there is a maximun number of vertices in shortest path.</p>
</blockquote>
<pre><code>for (n times of relax)
    for (each <span class="hljs-keyword">node</span><span class="hljs-title">)
        relax</span> each <span class="hljs-keyword">node</span><span class="hljs-title"></span>
</code></pre><h4 id="5-3-3-spfa">5.3.3 SPFA</h4>
<h4 id="5-3-4-dijkstra">5.3.4 Dijkstra</h4>
<blockquote>
<p>Dijkstra is good for graphs non-negative edges.</p>
<p>O(Vlog(E)) (?)</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-keyword">void</span> dijkstra(<span class="hljs-keyword">int</span> s) {
    map&lt;<span class="hljs-keyword">int</span>, queue&lt;<span class="hljs-keyword">int</span>&gt;&gt; m;
    dist[s] = <span class="hljs-number">0</span>;
    m[<span class="hljs-number">0</span>].<span class="hljs-keyword">push</span>(s);
    <span class="hljs-keyword">while</span> (m.<span class="hljs-keyword">size</span>()) {
        <span class="hljs-keyword">if</span> (!m.begin()-&gt;second.<span class="hljs-keyword">size</span>()) {
            m.erase(m.begin());
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">int</span> cur = m.begin()-&gt;second.front();
        m.begin()-&gt;second.<span class="hljs-keyword">pop</span>();
        <span class="hljs-keyword">if</span> (done[cur]) <span class="hljs-keyword">continue</span>;
        done[cur] = <span class="hljs-keyword">true</span>;
        SHOW(cur, dist[cur])
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-keyword">next</span> : children[cur]) {
            <span class="hljs-keyword">if</span> (!done[<span class="hljs-keyword">next</span>] &amp;&amp; dist[<span class="hljs-keyword">next</span>] &gt; dist[cur] + edge[cur][<span class="hljs-keyword">next</span>]) {
                dist[<span class="hljs-keyword">next</span>] = dist[cur] + edge[cur][<span class="hljs-keyword">next</span>];
                prev[<span class="hljs-keyword">next</span>] = cur;
                m[dist[<span class="hljs-keyword">next</span>]].<span class="hljs-keyword">push</span>(<span class="hljs-keyword">next</span>);
            }
        }
    }
    cout &lt;&lt; endl;
}
</code></pre>
<p>If you want to write compare operator().</p>
<pre><code class="lang-c++">struct cmp {
    bool operator()(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; a, pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; b) {
        <span class="hljs-keyword">return</span> a.first &gt; b.first;
    }
};

<span class="hljs-keyword">void</span> dijkstra(<span class="hljs-keyword">int</span> s) {
    priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, cmp&gt; q;
    q.<span class="hljs-keyword">push</span>(make_pair(<span class="hljs-number">0</span>, s));
    dist[s] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (q.<span class="hljs-keyword">size</span>()) {
        <span class="hljs-keyword">int</span> cur = q.top().second;
        q.<span class="hljs-keyword">pop</span>();
        <span class="hljs-keyword">if</span> (done[cur]) <span class="hljs-keyword">continue</span>;
        done[cur] = <span class="hljs-keyword">true</span>;
        SHOW(cur, dist[cur])
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-keyword">next</span> : children[cur]) {
            <span class="hljs-keyword">if</span> (!done[<span class="hljs-keyword">next</span>] &amp;&amp; dist[<span class="hljs-keyword">next</span>] &gt; dist[cur] + edge[cur][<span class="hljs-keyword">next</span>]) {
                dist[<span class="hljs-keyword">next</span>] = dist[cur] + edge[cur][<span class="hljs-keyword">next</span>];
                q.<span class="hljs-keyword">push</span>(make_pair(dist[<span class="hljs-keyword">next</span>], <span class="hljs-keyword">next</span>));
                prev[<span class="hljs-keyword">next</span>] = cur;
            }
        }
    }
}
</code></pre>
<h3 id="5-4-maximum-matching">5.4 Maximum Matching</h3>
<h4 id="5-4-1-on-bipartite-graph-">5.4.1 on Bipartite Graph 二分图</h4>
<blockquote>
<ol>
<li>A graph is bipartite if and only if it does not contain an odd cycle.</li>
<li>A graph is bipartite if and only if it is 2-colorable, (i.e. its chromatic number is less than or equal to 2).</li>
<li>The spectrum of a graph is symmetric if and only if it&#39;s a bipartite graph.</li>
</ol>
</blockquote>
<h5 id="5-4-1-1-hungarian-algorithm-">5.4.1.1 Hungarian algorithm 匈牙利算法</h5>
<blockquote>
<p>O(E * V)</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> Network {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> pre_edge;
        <span class="hljs-keyword">int</span> cap;
        <span class="hljs-keyword">int</span> flow;
    };

    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXNODE 405</span>
    <span class="hljs-keyword">int</span> last[MAXNODE];

    <span class="hljs-keyword">int</span> nv; <span class="hljs-comment">// total number of vertex, index range: [0, nv)</span>
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _nv)</span> </span>{
        nv = _nv;
        edge.clear();
        fill(last, last + nv, <span class="hljs-number">-1</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> r_cap = <span class="hljs-number">0</span>)</span> </span>{
        Edge e = {y, last[x], cap, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// Edge e{y, last[x], cap, 0};</span>
        last[x] = edge.size();
        <span class="hljs-comment">// edge.push_back(move(e));</span>
        edge.push_back(e);

        Edge r_e = {x, last[y], r_cap, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// Edge r_e{x, last[y], r_cap, 0};</span>
        last[y] = edge.size();
        <span class="hljs-comment">// edge.push_back(move(r_e));</span>
        edge.push_back(r_e);
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_edge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"v [%d]:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[i]; ie != <span class="hljs-number">-1</span>; ) {
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie]; 
                ie = e.pre_edge;
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" [%d]%d/%d"</span>, e.to, e.flow, e.cap);
            }
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }

    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// bipartite match</span>
    <span class="hljs-comment">// O(V * E)</span>
    <span class="hljs-keyword">int</span> peer[MAXNODE];
    <span class="hljs-keyword">bool</span> went[MAXNODE];
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bipartite_match</span><span class="hljs-params">()</span> </span>{
        fill(peer, peer + nv, <span class="hljs-number">-1</span>);
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) {
            <span class="hljs-keyword">if</span> (last[i] == <span class="hljs-number">-1</span> || peer[i] != <span class="hljs-number">-1</span>)
                <span class="hljs-keyword">continue</span>;
            fill(went, went + nv, <span class="hljs-literal">false</span>);
            <span class="hljs-keyword">if</span> (match(i))
                ans++;
        }
        <span class="hljs-keyword">return</span> ans;
    }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[cur]; ie != <span class="hljs-number">-1</span>; ) {
            <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
            ie = e.pre_edge;
            <span class="hljs-keyword">int</span> to = e.to;
            <span class="hljs-keyword">if</span> (went[to])
                <span class="hljs-keyword">continue</span>;
            went[to] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (peer[to] == <span class="hljs-number">-1</span> || match(peer[to])) {
                peer[to] = cur;
                peer[cur] = to;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_peer</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d peer-&gt; %d\n"</span>, i, peer[i]);
    }
    <span class="hljs-comment">// end of </span>
    <span class="hljs-comment">// bipartite match</span>
    <span class="hljs-comment">// </span>
};
</code></pre>
<h5 id="5-4-1-2-hopcroft-karp-algorithm">5.4.1.2 Hopcroft–Karp Algorithm</h5>
<blockquote>
<p>O(sqrt(V)*E)</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 1010</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXINT 0x7fffffff</span>

<span class="hljs-keyword">int</span> n, m, top, x, y;
<span class="hljs-keyword">int</span> ans;

<span class="hljs-keyword">int</span> disx[MAXN], disy[MAXN], matx[MAXN], maty[MAXN];<span class="hljs-comment">//x,y,分别为二分图的两个点集,mat为每个点在对侧集合的匹配点,如果当前没有匹配点则为-1 </span>

<span class="hljs-keyword">struct</span> edge {
    <span class="hljs-keyword">int</span> to;
    edge *next;
}e[MAXN*MAXN], *prev[MAXN];

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span> </span>{
    e[++top].to = v;
    e[top].next = prev[u];
    prev[u] = &amp;e[top];
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 寻找最短增广路 </span>
    <span class="hljs-keyword">bool</span> ret = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
    <span class="hljs-built_in">memset</span>(disx, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(disx));
    <span class="hljs-built_in">memset</span>(disy, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(disy));
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)
        <span class="hljs-keyword">if</span> (matx[i] == <span class="hljs-number">-1</span>)
            q.push(i); <span class="hljs-comment">// 找到未盖点,入队 </span>
    <span class="hljs-keyword">while</span> (!q.empty()) { <span class="hljs-comment">// 在二分图另一个点集的非盖点中寻找增广路 </span>
        <span class="hljs-keyword">int</span> x = q.front(); q.pop();
        <span class="hljs-keyword">for</span> (edge *i = prev[x]; i; i = i-&gt;next)
            <span class="hljs-keyword">if</span> (!disy[i-&gt;to]) {
                disy[i-&gt;to] = disx[x] + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">if</span> (maty[i-&gt;to]==<span class="hljs-number">-1</span>)
                    ret = <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到增广路 </span>
                <span class="hljs-keyword">else</span>
                    disx[maty[i-&gt;to]] = disy[i-&gt;to] + <span class="hljs-number">1</span>, q.push(maty[i-&gt;to]);    
            }
    }
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{ <span class="hljs-comment">// 沿增广路增广 </span>
    <span class="hljs-keyword">for</span> (edge *i = prev[x]; i; i = i-&gt;next) {
        <span class="hljs-keyword">if</span> (disy[i-&gt;to] == disx[x] + <span class="hljs-number">1</span>) {
            disy[i-&gt;to] = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (maty[i-&gt;to] == <span class="hljs-number">-1</span> || dfs(maty[i-&gt;to])) {
                matx[x] = i-&gt;to;
                maty[i-&gt;to] = x;
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);
    <span class="hljs-built_in">memset</span>(matx, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(matx));
    <span class="hljs-built_in">memset</span>(maty, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(maty));
    <span class="hljs-comment">/*for (int i=1;i&lt;=n;i++)
    {
        scanf("%d%d",&amp;x,&amp;y);x++;y++;
        insert(i,x);insert(i,y);
    }建图请自动忽略*/</span>
    <span class="hljs-keyword">while</span> (bfs()) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)
            <span class="hljs-keyword">if</span> (matx[i] == <span class="hljs-number">-1</span> &amp;&amp; dfs(i))
                ans++;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h4 id="5-4-2-on-general-graph">5.4.2 on General Graph</h4>
<h5 id="5-4-2-1-blossom-algorithm">5.4.2.1 Blossom Algorithm</h5>
<p><a href="http://www.conlan.cc/2013/03/08/%E4%B8%80%E8%88%AC%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/">一般图最大匹配</a></p>
<pre><code class="lang-c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NMax = <span class="hljs-number">230</span>;

<span class="hljs-keyword">int</span> Next[NMax];
<span class="hljs-keyword">int</span> spouse[NMax];
<span class="hljs-keyword">int</span> belong[NMax];

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findb</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>{
    <span class="hljs-keyword">return</span> belong[a] == a ? a : belong[a] = findb(belong[a]);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">together</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>{
    a = findb(a), b = findb(b);
    <span class="hljs-keyword">if</span> (a != b)
        belong[a] = b;
}

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; E[NMax];
<span class="hljs-keyword">int</span> N;
<span class="hljs-keyword">int</span> Q[NMax],bot;
<span class="hljs-keyword">int</span> mark[NMax];
<span class="hljs-keyword">int</span> visited[NMax];

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLCA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;
    t++;
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (x!=<span class="hljs-number">-1</span>) {
            x = findb(x);
            <span class="hljs-keyword">if</span> (visited[x] == t)
                <span class="hljs-keyword">return</span> x;
            visited[x] = t;
            <span class="hljs-keyword">if</span> (spouse[x] != <span class="hljs-number">-1</span>)
                x = Next[spouse[x]];
            <span class="hljs-keyword">else</span> x = <span class="hljs-number">-1</span>;
        }
        swap(x,y);
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">goup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> p)</span> </span>{
    <span class="hljs-keyword">while</span> (a != p) {
        <span class="hljs-keyword">int</span> b = spouse[a], c = Next[b];
        <span class="hljs-keyword">if</span> (findb(c) != p)
            Next[c] = b;
        <span class="hljs-keyword">if</span> (mark[b] == <span class="hljs-number">2</span>) 
            mark[Q[bot++] = b] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (mark[c] == <span class="hljs-number">2</span>)
            mark[Q[bot++] = c] = <span class="hljs-number">1</span>;
        together(a,b);
        together(b,c);
        a = c;
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findaugment</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)
        Next[i] = <span class="hljs-number">-1</span>, belong[i] = i, mark[i] = <span class="hljs-number">0</span>, visited[i] = <span class="hljs-number">-1</span>;
    Q[<span class="hljs-number">0</span>] = s; 
    bot = <span class="hljs-number">1</span>; 
    mark[s] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>; spouse[s] == <span class="hljs-number">-1</span> &amp;&amp; head &lt; bot; head++) {
        <span class="hljs-keyword">int</span> x = Q[head];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-keyword">int</span>)E[x].size(); i++) {
            <span class="hljs-keyword">int</span> y = E[x][i];
            <span class="hljs-keyword">if</span> (spouse[x] != y &amp;&amp; findb(x) != findb(y) &amp;&amp; mark[y] != <span class="hljs-number">2</span>) {
                <span class="hljs-keyword">if</span> (mark[y] == <span class="hljs-number">1</span>) {
                    <span class="hljs-keyword">int</span> p = findLCA(x,y);
                    <span class="hljs-keyword">if</span> (findb(x) != p) 
                        Next[x] = y;
                    <span class="hljs-keyword">if</span> (findb(y) != p) 
                        Next[y] = x;
                    goup(x,p);
                    goup(y,p);
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (spouse[y] == <span class="hljs-number">-1</span>) {
                    Next[y] = x;
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = y; j != <span class="hljs-number">-1</span>; ) {
                        <span class="hljs-keyword">int</span> k = Next[j];
                        <span class="hljs-keyword">int</span> l = spouse[k];
                        spouse[j] = k;
                        spouse[k] = j;
                        j = l;
                    }
                    <span class="hljs-keyword">break</span>;
                }
                <span class="hljs-keyword">else</span>{
                    Next[y] = x;
                    mark[Q[bot++] = spouse[y]] = <span class="hljs-number">1</span>;
                    mark[y] = <span class="hljs-number">2</span>;
                }
            }
        }
    }
}

<span class="hljs-keyword">int</span> Map[NMax][NMax];

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">memset</span>(Map, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(Map));

    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;N);
    <span class="hljs-keyword">int</span> x, y;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y) != EOF) {
        x--;
        y--;
        <span class="hljs-keyword">if</span> (x != y &amp;&amp; !Map[x][y]) {
            Map[x][y] = Map[y][x] = <span class="hljs-number">1</span>;
            E[x].push_back(y);
            E[y].push_back(x);
        }
    }
    <span class="hljs-built_in">memset</span>(spouse, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(spouse));
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)
        <span class="hljs-keyword">if</span> (spouse[i] == <span class="hljs-number">-1</span>)
            findaugment(i);
    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)
        <span class="hljs-keyword">if</span> (spouse[i] != <span class="hljs-number">-1</span>)
            ret++;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ret);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)
        <span class="hljs-keyword">if</span> (spouse[i] != <span class="hljs-number">-1</span> &amp;&amp; spouse[i] &gt; i)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"pair: %d %d\n"</span>, i + <span class="hljs-number">1</span>, spouse[i] + <span class="hljs-number">1</span>);
}
</code></pre>
<h3 id="5-5-maximum-flow-problem-">5.5 Maximum Flow Problem 最大流</h3>
<h4 id="5-5-1-dinic">5.5.1 Dinic</h4>
<pre><code class="lang-c++"><span class="hljs-comment">// a convenient class</span>

<span class="hljs-keyword">struct</span> Network {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> pre_edge;
        <span class="hljs-keyword">int</span> cap;
        <span class="hljs-keyword">int</span> flow;
    };

    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXNODE 405</span>
    <span class="hljs-keyword">int</span> last[MAXNODE];

    <span class="hljs-keyword">int</span> nv; <span class="hljs-comment">// total number of vertex, index range: [0, nv)</span>
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _nv)</span> </span>{
        nv = _nv;
        edge.clear();
        fill(last, last + nv, <span class="hljs-number">-1</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> r_cap = <span class="hljs-number">0</span>)</span> </span>{
        Edge e = {y, last[x], cap, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// Edge e{y, last[x], cap, 0};</span>
        last[x] = edge.size();
        <span class="hljs-comment">// edge.push_back(move(e));</span>
        edge.push_back(e);

        Edge r_e = {x, last[y], r_cap, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// Edge r_e{x, last[y], r_cap, 0};</span>
        last[y] = edge.size();
        <span class="hljs-comment">// edge.push_back(move(r_e));</span>
        edge.push_back(r_e);
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_edge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"v [%d]:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[i]; ie != <span class="hljs-number">-1</span>; ) {
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie]; 
                ie = e.pre_edge;
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" [%d]%d/%d"</span>, e.to, e.flow, e.cap);
            }
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }

    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// maximum flow</span>
    <span class="hljs-comment">// dinic O(V * V * E)</span>
    <span class="hljs-keyword">int</span> lv[MAXNODE];
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mark_level</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
        fill(lv, lv + MAXNODE, <span class="hljs-number">-1</span>);
        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
        lv[start] = <span class="hljs-number">0</span>;
        q.push(start);
        <span class="hljs-keyword">while</span> (!q.empty()) {
            <span class="hljs-keyword">int</span> cur = q.front(); q.pop();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[cur]; ie != <span class="hljs-number">-1</span>; ) {
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie]; 
                ie = e.pre_edge;
                <span class="hljs-keyword">if</span> (e.cap != e.flow &amp;&amp; lv[e.to] == <span class="hljs-number">-1</span>) {
                    lv[e.to] = lv[cur] + <span class="hljs-number">1</span>;
                    q.push(e.to);
                }
            }
        }
        <span class="hljs-keyword">return</span> lv[end] != <span class="hljs-number">-1</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_lv</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"lv[%d] = %d\n"</span>, i, lv[i]);
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">augment</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> min_flow)</span> </span>{
        <span class="hljs-keyword">if</span> (cur == end)
            <span class="hljs-keyword">return</span> min_flow;

        <span class="hljs-keyword">int</span> augmented_flow = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[cur]; ie != <span class="hljs-number">-1</span>; ) {
            Edge&amp; e = edge[ie]; 
            Edge&amp; re = edge[ie ^ <span class="hljs-number">1</span>];
            ie = e.pre_edge;
            <span class="hljs-keyword">if</span> (lv[e.to] == lv[cur] + <span class="hljs-number">1</span> &amp;&amp;
                e.cap &gt; e.flow &amp;&amp;
                (augmented_flow = augment(e.to, end, min(e.cap - e.flow, min_flow)))
            ) {
                e.flow += augmented_flow;
                re.flow -= augmented_flow;
                <span class="hljs-keyword">return</span> augmented_flow;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
        <span class="hljs-keyword">int</span> total_flow = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> flow = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (mark_level(start, end)) <span class="hljs-comment">// update level</span>
            <span class="hljs-keyword">while</span> (flow = augment(start, end, INT_MAX)) <span class="hljs-comment">// eat up all augmented flow</span>
                total_flow += flow;
        <span class="hljs-keyword">return</span> total_flow;
    }
    <span class="hljs-comment">// end of</span>
    <span class="hljs-comment">// maximum flow - dinic</span>
    <span class="hljs-comment">// </span>
};
</code></pre>
<h4 id="5-5-2-improved-sap-gap-optimization">5.5.2 Improved SAP + Gap Optimization</h4>
<blockquote>
<p>TODO add more optimizations</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> Network {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;
        <span class="hljs-keyword">int</span> pre_edge;
        <span class="hljs-keyword">int</span> cap;
        <span class="hljs-keyword">int</span> flow;
    };

    #define MAXNODE <span class="hljs-number">405</span>
    <span class="hljs-keyword">int</span> last[MAXNODE];

    <span class="hljs-keyword">int</span> nv; <span class="hljs-comment">// total number of vertex, index range: [0, nv)</span>
    vector&lt;Edge&gt; <span class="hljs-keyword">edge</span>;
    <span class="hljs-keyword">void</span> init(<span class="hljs-keyword">int</span> <span class="hljs-number">_</span>nv) {
        nv = <span class="hljs-number">_</span>nv;
        <span class="hljs-keyword">edge</span><span class="hljs-variable">.clear</span>();
        fill(last, last + nv, -<span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">void</span> add_e(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> r_cap = <span class="hljs-number">0</span>) {
        Edge e = {y, last[x], cap, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// Edge e{y, last[x], cap, 0};</span>
        last[x] = <span class="hljs-keyword">edge</span><span class="hljs-variable">.size</span>();
        <span class="hljs-comment">// edge.push_back(move(e));</span>
        <span class="hljs-keyword">edge</span><span class="hljs-variable">.push_back</span>(e);

        Edge r_e = {x, last[y], r_cap, <span class="hljs-number">0</span>};
        <span class="hljs-comment">// Edge r_e{x, last[y], r_cap, 0};</span>
        last[y] = <span class="hljs-keyword">edge</span><span class="hljs-variable">.size</span>();
        <span class="hljs-comment">// edge.push_back(move(r_e));</span>
        <span class="hljs-keyword">edge</span><span class="hljs-variable">.push_back</span>(r_e);
    }
    <span class="hljs-keyword">void</span> show_edge() {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nv; i++) {
            printf(<span class="hljs-string">"v [%d]:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[i]; ie != -<span class="hljs-number">1</span>; ) {
                <span class="hljs-keyword">const</span> Edge&amp; e = <span class="hljs-keyword">edge</span>[ie]; 
                ie = e<span class="hljs-variable">.pre_edge</span>;
                printf(<span class="hljs-string">" [%d]%d/%d"</span>, e<span class="hljs-variable">.to</span>, e<span class="hljs-variable">.flow</span>, e<span class="hljs-variable">.cap</span>);
            }
            printf(<span class="hljs-string">"\n"</span>);
        }
        printf(<span class="hljs-string">"\n"</span>);
    }

    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// maximum flow</span>
    <span class="hljs-comment">// isap + gap O(V * V * E)</span>
    <span class="hljs-comment">// a bit faster than dinic</span>
    <span class="hljs-keyword">int</span> lv[MAXNODE];
    <span class="hljs-keyword">int</span> lv_count[MAXNODE];
    <span class="hljs-keyword">int</span> from_edge[MAXNODE];
    <span class="hljs-keyword">void</span> mark_r_level(<span class="hljs-keyword">int</span> <span class="hljs-keyword">end</span>) {
        fill(lv, lv + nv, nv);
        fill(lv_count, lv_count + nv, <span class="hljs-number">0</span>);
        queue&lt;<span class="hljs-keyword">int</span>&gt; q;

        lv[<span class="hljs-keyword">end</span>] = <span class="hljs-number">0</span>;
        lv_count[lv[<span class="hljs-keyword">end</span>]]++;
        q<span class="hljs-variable">.push</span>(<span class="hljs-keyword">end</span>);
        <span class="hljs-keyword">while</span> (!q<span class="hljs-variable">.empty</span>()) {
            <span class="hljs-keyword">int</span> cur = q<span class="hljs-variable">.front</span>(); q<span class="hljs-variable">.pop</span>();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[cur]; ie != -<span class="hljs-number">1</span>; ) {
                <span class="hljs-keyword">const</span> Edge&amp; e = <span class="hljs-keyword">edge</span>[ie]; 
                ie = e<span class="hljs-variable">.pre_edge</span>;
                <span class="hljs-keyword">int</span> to = e<span class="hljs-variable">.to</span>;
                <span class="hljs-keyword">if</span> (lv[to] != nv)
                    <span class="hljs-keyword">continue</span>;

                lv[to] = lv[cur] + <span class="hljs-number">1</span>;
                lv_count[lv[to]]++;
                q<span class="hljs-variable">.push</span>(to);
            }
        }
    }
    <span class="hljs-keyword">int</span> isap_gap(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-keyword">end</span>) {
        mark_r_level(<span class="hljs-keyword">end</span>); <span class="hljs-comment">// reverse bfs to get level of node</span>

        <span class="hljs-keyword">int</span> total_flow = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> cur = start;
        from_edge[start] = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (lv[start] &lt; nv) {
            <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">end</span>) {
                <span class="hljs-keyword">int</span> flow = INT_MAX;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = cur; x != start; ) { <span class="hljs-comment">// backtrack to get min cap along the path</span>
                    <span class="hljs-keyword">int</span> ie = from_edge[x];
                    <span class="hljs-keyword">const</span> Edge&amp; e = <span class="hljs-keyword">edge</span>[ie];
                    flow = min(flow, e<span class="hljs-variable">.cap</span> - e<span class="hljs-variable">.flow</span>);
                    x = <span class="hljs-keyword">edge</span>[ie ^ <span class="hljs-number">1</span>]<span class="hljs-variable">.to</span>;
                }

                <span class="hljs-keyword">for</span> ( ; cur != start; ) { <span class="hljs-comment">// update the cap along the path</span>
                    <span class="hljs-keyword">int</span> ie = from_edge[cur];
                    Edge&amp; e = <span class="hljs-keyword">edge</span>[ie];
                    Edge&amp; re = <span class="hljs-keyword">edge</span>[ie ^ <span class="hljs-number">1</span>];
                    e<span class="hljs-variable">.flow</span> += flow;
                    re<span class="hljs-variable">.flow</span> -= flow;
                    cur = re<span class="hljs-variable">.to</span>;
                }
                total_flow += flow;
            }

            bool found = false;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[cur]; ie != -<span class="hljs-number">1</span>; ) { <span class="hljs-comment">// find the next vertex</span>
                <span class="hljs-keyword">const</span> Edge&amp; e = <span class="hljs-keyword">edge</span>[ie]; 
                <span class="hljs-keyword">if</span> (e<span class="hljs-variable">.cap</span> != e<span class="hljs-variable">.flow</span> &amp;&amp; lv[cur] == lv[e<span class="hljs-variable">.to</span>] + <span class="hljs-number">1</span>) {
                    cur = e<span class="hljs-variable">.to</span>;
                    from_edge[cur] = ie; <span class="hljs-comment">// record the edge from which we comes</span>
                    found = true;
                    <span class="hljs-keyword">break</span>;
                }
                ie = e<span class="hljs-variable">.pre_edge</span>;
            }

            <span class="hljs-keyword">if</span> (found)
                <span class="hljs-keyword">continue</span>;

            lv_count[lv[cur]]--;
            <span class="hljs-keyword">if</span> (lv_count[lv[cur]] == <span class="hljs-number">0</span>)
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">int</span> min_lv = nv;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie = last[cur]; ie != -<span class="hljs-number">1</span>; ) { <span class="hljs-comment">// find the min level around cur vertex</span>
                <span class="hljs-keyword">const</span> Edge&amp; e = <span class="hljs-keyword">edge</span>[ie]; 
                ie = e<span class="hljs-variable">.pre_edge</span>;

                <span class="hljs-keyword">if</span> (e<span class="hljs-variable">.cap</span> != e<span class="hljs-variable">.flow</span>)
                    min_lv = min(min_lv, lv[e<span class="hljs-variable">.to</span>]);
            }

            lv[cur] = min_lv + <span class="hljs-number">1</span>; <span class="hljs-comment">// raise level of cur vertex by 1</span>
            lv_count[lv[cur]]++;
            <span class="hljs-keyword">if</span> (cur != start)
                cur = <span class="hljs-keyword">edge</span>[from_edge[cur] ^ <span class="hljs-number">1</span>]<span class="hljs-variable">.to</span>; <span class="hljs-comment">// revert one step</span>
        }
        <span class="hljs-keyword">return</span> total_flow;
    }
    <span class="hljs-comment">// end of </span>
    <span class="hljs-comment">// maximum flow - isap + gap</span>
    <span class="hljs-comment">// </span>
};
</code></pre>
<h4 id="5-5-3-minimum-cost-maximum-flow">5.5.3 Minimum-Cost Maximum-Flow</h4>
<pre><code class="lang-C++">// have not tested
int n_node;
int n_edge;

int cost[<span class="hljs-number">405</span>][<span class="hljs-number">405</span>]; // cost[i][j] = -cost[j][i]
int residual[<span class="hljs-number">405</span>][<span class="hljs-number">405</span>];

bool bellman_ford(int&amp; flow_sum, int&amp;cost_sum) { // <span class="hljs-number">0</span>: start, n_node - <span class="hljs-number">1</span>: end
    int min_cost[<span class="hljs-number">405</span>]; for (int i = <span class="hljs-number">0</span>; i &lt; n_node; i++) min_cost[i] = <span class="hljs-symbol">INT_MAX</span>; min_cost[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    int pre_node[<span class="hljs-number">405</span>]; pre_node[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    int max_flow[<span class="hljs-number">405</span>];
    int in_queue[<span class="hljs-number">405</span>]; memset(in_queue, <span class="hljs-number">0</span>, sizeof(in_queue));

    queue&lt;int&gt; q;
    q.push(<span class="hljs-number">0</span>);
    while (q.size()) {
        int cur = q.front(); q.pop();
        in_queue[cur] = <span class="hljs-number">0</span>;

        for (int i = <span class="hljs-number">0</span>; i &lt; n_node; i++) {
            if (residual[cur][i] &gt; <span class="hljs-number">0</span> &amp;&amp; min_cost[i] &gt; min_cost[cur] + cost[cur][i]) {
                min_cost[i] = min_cost[cur] + cost[cur][i];
                pre_node[i] = cur;
                max_flow[i] = min(max_flow[cur], residual[cur][i]);

                if (in_queue[i] == <span class="hljs-number">0</span>) {
                    in_queue[i] = <span class="hljs-number">1</span>;
                    q.push(i);
                }
            }
        }
    }
    if (min_cost[n_node - <span class="hljs-number">1</span>] == <span class="hljs-symbol">INT_MAX</span>)
        return false;
    flow_sum += max_flow[n_node - <span class="hljs-number">1</span>];
    cost_sum += max_flow[n_node - <span class="hljs-number">1</span>] * min_cost[n_node - <span class="hljs-number">1</span>];
    for (int cur = n_node - <span class="hljs-number">1</span>; cur != <span class="hljs-number">0</span>; cur = pre_node[cur]) {
        residual[pre_node[cur]][cur] -= max_flow[n_node - <span class="hljs-number">1</span>];
        residual[cur][pre_node[cur]] += max_flow[n_node - <span class="hljs-number">1</span>];
    }
    return true;
}

void min_cost_max_flow() {
    int flow_sum = <span class="hljs-number">0</span>;
    int cost_sum = <span class="hljs-number">0</span>;
    while (bellman_ford(flow_sum, cost_sum));
    cout &lt;&lt; flow_sum &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; cost_sum &lt;&lt; endl;
}
</code></pre>
<h4 id="5-5-4-more-applications-and-properties">5.5.4 More Applications and Properties</h4>
<blockquote>
<p>placeholder</p>
</blockquote>
<h3 id="5-6-">5.6 强连通分量 图的 割点, 桥, 双连通分支</h3>
<p><code>https://www.byvoid.com/blog/biconnect</code></p>
<blockquote>
<p>[点连通度与边连通度]</p>
<p>在一个无向连通图中，如果有一个顶点集合，删除这个顶点集合，以及这个集合中所有顶点相关联的边以后，原图变成多个连通块，就称这个点集为割点集合。一个图的点连通度的定义为，最小割点集合中的顶点数。</p>
<p>类似的，如果有一个边集合，删除这个边集合以后，原图变成多个连通块，就称这个点集为割边集合。一个图的边连通度的定义为，最小割边集合中的边数。</p>
<p>[双连通图、割点与桥]</p>
<p>如果一个无向连通图的点连通度大于1，则称该图是点双连通的(point biconnected)，简称双连通或重连通。一个图有割点，当且仅当这个图的点连通度为1，则割点集合的唯一元素被称为割点(cut point)，又叫关节点(articulation point)。</p>
<p>如果一个无向连通图的边连通度大于1，则称该图是边双连通的(edge biconnected)，简称双连通或重连通。一个图有桥，当且仅当这个图的边连通度为1，则割边集合的唯一元素被称为桥(bridge)，又叫关节边(articulation edge)。</p>
<p>可以看出，点双连通与边双连通都可以简称为双连通，它们之间是有着某种联系的，下文中提到的双连通，均既可指点双连通，又可指边双连通。</p>
<p>[双连通分支]</p>
<p>在图G的所有子图G&#39;中，如果G&#39;是双连通的，则称G&#39;为双连通子图。如果一个双连通子图G&#39;它不是任何一个双连通子图的真子集，则G&#39;为极大双连通子图。双连通分支(biconnected component)，或重连通分支，就是图的极大双连通子图。特殊的，点双连通分支又叫做块。</p>
<p>[求割点与桥]</p>
<p>该算法是R.Tarjan发明的。对图深度优先搜索，定义DFS(u)为u在搜索树（以下简称为树）中被遍历到的次序号。定义Low(u)为u或u的子树中能通过非父子边追溯到的最早的节点，即DFS序号最小的节点。根据定义，则有：</p>
<p>Low(u)=Min { DFS(u) DFS(v) (u,v)为后向边(返祖边) 等价于 DFS(v)&lt;DFS(u)且v不为u的父亲节点 Low(v) (u,v)为树枝边(父子边) }</p>
<p>一个顶点u是割点，当且仅当满足(1)或(2) (1) u为树根，且u有多于一个子树。 (2) u不为树根，且满足存在(u,v)为树枝边(或称父子边，即u为v在搜索树中的父亲)，使得DFS(u)&lt;=Low(v)。</p>
<p>一条无向边(u,v)是桥，当且仅当(u,v)为树枝边，且满足DFS(u)&lt;Low(v)。</p>
<p>[求双连通分支]</p>
<p>下面要分开讨论点双连通分支与边双连通分支的求法。</p>
<p>对于点双连通分支，实际上在求割点的过程中就能顺便把每个点双连通分支求出。建立一个栈，存储当前双连通分支，在搜索图时，每找到一条树枝边或后向边(非横叉边)，就把这条边加入栈中。如果遇到某时满足DFS(u)&lt;=Low(v)，说明u是一个割点，同时把边从栈顶一个个取出，直到遇到了边(u,v)，取出的这些边与其关联的点，组成一个点双连通分支。割点可以属于多个点双连通分支，其余点和每条边只属于且属于一个点双连通分支。</p>
<p>对于边双连通分支，求法更为简单。只需在求出所有的桥以后，把桥边删除，原图变成了多个连通块，则每个连通块就是一个边双连通分支。桥不属于任何一个边双连通分支，其余的边和每个顶点都属于且只属于一个边双连通分支。</p>
<p>[构造双连通图]</p>
<p>一个有桥的连通图，如何把它通过加边变成边双连通图？方法为首先求出所有的桥，然后删除这些桥边，剩下的每个连通块都是一个双连通子图。把每个双连通子图收缩为一个顶点，再把桥边加回来，最后的这个图一定是一棵树，边连通度为1。</p>
<p>统计出树中度为1的节点的个数，即为叶节点的个数，记为leaf。则至少在树上添加(leaf+1)/2条边，就能使树达到边二连通，所以至少添加的边数就是(leaf+1)/2。具体方法为，首先把两个最近公共祖先最远的两个叶节点之间连接一条边，这样可以把这两个点到祖先的路径上所有点收缩到一起，因为一个形成的环一定是双连通的。然后再找两个最近公共祖先最远的两个叶节点，这样一对一对找完，恰好是(leaf+1)/2次，把所有点收缩到了一起。</p>
</blockquote>
<p>find articulation point (cut vertex) / bridge (cutedge) in directed / undirected graph</p>
<p>find and merge biconnected component in undirected graph</p>
<p>find and merge strongly connected component in directed graph</p>
<p>time complexity <code>O(E+V)</code></p>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NN 20002</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MM 100002</span>

<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">int</span> m;

<span class="hljs-keyword">int</span> visit_order[NN];
<span class="hljs-keyword">int</span> smallest_order_can_reach[NN];
<span class="hljs-keyword">int</span> parent[NN];
<span class="hljs-keyword">int</span> in_stack[NN];
<span class="hljs-keyword">int</span> temp_component[NN];

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[NN];

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; component)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; out_vertex;
    <span class="hljs-keyword">int</span> new_vertex = component.back();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : component)
        temp_component[v] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : component) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> o : g[v]) {
            <span class="hljs-keyword">if</span> (!temp_component[o])
                out_vertex.push_back(o);
        }
        g[v].clear();
        g[v].push_back(new_vertex);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : component)
        temp_component[v] = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// use last vertex in the component as new vertex</span>
    g[new_vertex] = out_vertex;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> order = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;

    visit_order[cur] = smallest_order_can_reach[cur] = ++order;
    s.push(cur);
    in_stack[cur] = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">int</span> subtree = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> next : g[cur]) {
        <span class="hljs-keyword">if</span> (visit_order[next] == <span class="hljs-number">0</span>) {
            subtree++;
            parent[next] = cur;
            dfs(next);
            smallest_order_can_reach[cur] = min(smallest_order_can_reach[cur], smallest_order_can_reach[next]);

            <span class="hljs-comment">// if cur is root, and subtree &gt; 1</span>
            <span class="hljs-comment">// it is an articulation point</span>
            <span class="hljs-keyword">if</span> (visit_order[cur] == <span class="hljs-number">1</span> &amp;&amp; subtree &gt; <span class="hljs-number">1</span>)
                ;

            <span class="hljs-comment">// if cur is not root, and next cannot reach smaller vertex</span>
            <span class="hljs-comment">// it is an articulation point</span>
            <span class="hljs-keyword">if</span> (visit_order[cur] != <span class="hljs-number">1</span> &amp;&amp; visit_order[cur] &lt;= smallest_order_can_reach[next])
                ;

            <span class="hljs-comment">// if cannot use this edge to reach a smaller vertex</span>
            <span class="hljs-comment">// it is a bridge</span>
            <span class="hljs-keyword">if</span> (visit_order[cur] &lt; smallest_order_can_reach[next])
                ;
        }

            <span class="hljs-comment">// for undirected graph</span>
            <span class="hljs-comment">// update the smallness of vertex that can reach</span>
<span class="hljs-comment">//        else if (next != parent[cur])</span>
<span class="hljs-comment">//            smallest_order_can_reach[cur] = min(smallest_order_can_reach[cur], visit_order[next]);</span>

            <span class="hljs-comment">// for directed graph</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (in_stack[next])
            smallest_order_can_reach[cur] = min(smallest_order_can_reach[cur], visit_order[next]);
    }

    <span class="hljs-keyword">if</span> (visit_order[cur] == smallest_order_can_reach[cur]) {
        <span class="hljs-comment">// because visit_order[cur] == smallest_order_can_reach[cur]</span>
        <span class="hljs-comment">// and visit_order[cur] &gt; visit_order[parent[cur]]</span>
        <span class="hljs-comment">// so visit_order[parent[cur]] &lt; smallest_order_can_reach[cur]</span>
        <span class="hljs-comment">// so cur-parent[cur] is a bridge</span>
        <span class="hljs-comment">// cur is root of the biconnected component</span>
        <span class="hljs-comment">// so pop all util cur</span>

        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; component;
        <span class="hljs-keyword">int</span> min_vertex = s.top();
        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">int</span> vertex = s.top(); s.pop();
            in_stack[vertex] = <span class="hljs-number">0</span>;
            min_vertex = min(min_vertex, vertex);
            component.push_back(vertex);
            <span class="hljs-keyword">if</span> (vertex == cur)
                <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-comment">// cur is the last vertex in the component</span>
        merge(component);
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
        <span class="hljs-keyword">int</span> a, b;
        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;
        g[a].push_back(b);
    }

    dfs(<span class="hljs-number">1</span>);
}
</code></pre>
<h3 id="5-7-topological-sort-">5.7 Topological Sort / 拓扑排序</h3>
<blockquote>
<p>Topological Sorting on Directed Acyclic Graph (DAG)</p>
<p>time complexity <code>O(N)</code></p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-keyword">struct</span> Graph {
    <span class="hljs-keyword">struct</span> Edge {
        <span class="hljs-keyword">int</span> to;
    };

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXNODE = <span class="hljs-number">3</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; g[MAXNODE];
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edge;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nn)</span> </span>{
        n = nn;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)
            g[i].clear();
        edge.clear();
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
        Edge e = {y};
        g[x].push_back(edge.size());
        edge.push_back(e);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>, i);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>, edge[ie].to);
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }

    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// Node index ~ [0, N)</span>
    <span class="hljs-comment">// matters for topological sort</span>
    <span class="hljs-comment">// </span>
    <span class="hljs-keyword">int</span> in_order[MAXNODE];
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_in_order</span><span class="hljs-params">()</span> </span>{
        fill_n(in_order, n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[i])
                in_order[edge[ie].to]++;
    }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">topological_sort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span> </span>{
        init_in_order();
        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
            <span class="hljs-keyword">if</span> (in_order[i] == <span class="hljs-number">0</span>)
                q.push(i);
        <span class="hljs-keyword">while</span> (q.size()) {
            <span class="hljs-keyword">int</span> cur = q.front(); q.pop();
            result.push_back(cur);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ie : g[cur]) {
                <span class="hljs-keyword">const</span> Edge&amp; e = edge[ie];
                in_order[e.to]--;
                <span class="hljs-keyword">if</span> (in_order[e.to] == <span class="hljs-number">0</span>)
                    q.push(e.to);
            }
        }
        <span class="hljs-keyword">return</span> result.size() == n;
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_order</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"in_order[%d] = %d\n"</span>, i, in_order[i]);
    }
};
</code></pre>
<h3 id="5-8-euler-cycle-path-hamilton-cycle-path">5.8 Euler Cycle/Path, Hamilton Cycle/Path</h3>
<blockquote>
<p>place holder</p>
</blockquote>
<h3 id="5-9-find-negative-weight-cycle-on-a-graph">5.9 find negative (weight) Cycle on a graph</h3>
<blockquote>
<p>place holder</p>
</blockquote>
<h2 id="6-number-mathematics">6. Number + Mathematics</h2>
<h3 id="6-1-biginteger-bigdecimal">6.1 BigInteger + BigDecimal</h3>
<h4 id="6-1-1-c-big-integer">6.1.1 C++ Big Integer</h4>
<pre><code class="lang-c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> BASE_LENGTH = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> BASE = (<span class="hljs-keyword">int</span>) <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, BASE_LENGTH);
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX_LENGTH = <span class="hljs-number">500</span>;

<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">int_to_string</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">bool</span> zero)</span> </span>{
    <span class="hljs-built_in">string</span> res = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">while</span> (width--) {
        <span class="hljs-keyword">if</span> (!zero &amp;&amp; i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;
        res = (<span class="hljs-keyword">char</span>)(i%<span class="hljs-number">10</span> + <span class="hljs-string">'0'</span>) + res;
        i /= <span class="hljs-number">10</span>;
    }
    <span class="hljs-keyword">return</span> res;
}

<span class="hljs-keyword">struct</span> bigint {
    <span class="hljs-keyword">int</span> len, s[MAX_LENGTH];

    bigint() {  
        <span class="hljs-built_in">memset</span>(s, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s));  
        len = <span class="hljs-number">1</span>;  
    }

    bigint(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> num) {
        len = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (num &gt;= BASE) {
            s[len] = num % BASE;
            num /= BASE;
            len ++;
        }
        s[len++] = num;
    }

    bigint(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* num) {
        <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">strlen</span>(num);
        len = l/BASE_LENGTH;
        <span class="hljs-keyword">if</span> (l % BASE_LENGTH) len++;
        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -= BASE_LENGTH) {
            <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">int</span> k = i - BASE_LENGTH + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) k = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = k; j &lt;= i; j++) {
                tmp = tmp*<span class="hljs-number">10</span> + num[j] - <span class="hljs-string">'0'</span>;
            }
            s[index++] = tmp;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>{  
        <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">1</span> &amp;&amp; !s[len<span class="hljs-number">-1</span>]) len--;  
    }

    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">string</span> ret = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span> &amp;&amp; !s[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-string">"0"</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) {
                ret += int_to_string(s[len - i - <span class="hljs-number">1</span>], BASE_LENGTH, <span class="hljs-literal">false</span>);
            } <span class="hljs-keyword">else</span> {
                ret += int_to_string(s[len - i - <span class="hljs-number">1</span>], BASE_LENGTH, <span class="hljs-literal">true</span>);
            }
        }
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">ll</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            ret *= BASE;
            ret += s[i];
        }
        <span class="hljs-keyword">return</span> ret;
    }

    bigint <span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> bigint&amp; b) <span class="hljs-keyword">const</span> {
        bigint c = b;
        <span class="hljs-keyword">while</span> (c.len &lt; len) c.s[c.len++] = <span class="hljs-number">0</span>;
        c.s[c.len++] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">bool</span> r = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len || r; i++) {
            c.s[i] += (i&lt;len)*s[i] + r;
            r = c.s[i] &gt;= BASE;
            <span class="hljs-keyword">if</span> (r) c.s[i] -= BASE;
        }
        c.clean();
        <span class="hljs-keyword">return</span> c;
    }

    bigint <span class="hljs-keyword">operator</span> - (<span class="hljs-keyword">const</span> bigint&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">operator</span> &lt; (b)) <span class="hljs-keyword">throw</span> <span class="hljs-string">"cannot do subtract"</span>;
        bigint c = *<span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">bool</span> r = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; b.len || r; i++) {
            c.s[i] -= b.s[i];
            r = c.s[i] &lt; <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (r) c.s[i] += BASE;
        }
        c.clean();
        <span class="hljs-keyword">return</span> c;
    }

    bigint <span class="hljs-keyword">operator</span> * (<span class="hljs-keyword">const</span> bigint&amp; b) <span class="hljs-keyword">const</span> {  
        bigint c;
        c.len = len + b.len;  
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)  
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; b.len; j++)  
                c.s[i+j] += s[i] * b.s[j];  
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.len<span class="hljs-number">-1</span>; i++){  
            c.s[i+<span class="hljs-number">1</span>] += c.s[i] / BASE;  
            c.s[i] %= BASE;  
        }  
        c.clean();  
        <span class="hljs-keyword">return</span> c;  
    }

    bigint <span class="hljs-keyword">operator</span> / (<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b) <span class="hljs-keyword">const</span> {
        bigint ret;
        <span class="hljs-keyword">int</span> down = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            ret.s[i] = (s[i] + down * BASE) / b;
            down = s[i] + down * BASE - ret.s[i] * b;
        }
        ret.len = len;
        ret.clean();
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> bigint&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">if</span> (len &lt; b.len) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &gt; b.len) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
            <span class="hljs-keyword">if</span> (s[i] &lt; b.s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] &gt; b.s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-keyword">const</span> bigint&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span>&lt;b) &amp;&amp; !(b&lt;(*<span class="hljs-keyword">this</span>));
    }

    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &gt; (<span class="hljs-keyword">const</span> bigint&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> b &lt; *<span class="hljs-keyword">this</span>;
    }
};
</code></pre>
<p>Examples</p>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">((a+b)</span></span>.str()==<span class="hljs-string">"10001"</span>)
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">((a+b)</span></span>==bigint(<span class="hljs-number">10001</span>))
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">((b/<span class="hljs-number">2</span>)</span></span>==<span class="hljs-number">4999</span>)
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">(c == <span class="hljs-number">12345</span>)</span></span>
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">(c &lt; <span class="hljs-number">123456</span>)</span></span>
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">(c &gt; <span class="hljs-number">123</span>)</span></span>
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">(!(c &gt; <span class="hljs-number">123456</span>)</span></span>)
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">(!(c &lt; <span class="hljs-number">123</span>)</span></span>)
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">(!(c == <span class="hljs-number">12346</span>)</span></span>)
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">(!(c == <span class="hljs-number">12344</span>)</span></span>)
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">(c.str()</span></span> == <span class="hljs-string">"12345"</span>)
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">((b-<span class="hljs-number">1</span>)</span></span>==<span class="hljs-number">9998</span>)
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">(a.ll()</span></span> == <span class="hljs-number">2</span>)
<span class="hljs-function"><span class="hljs-title">ASSERT</span><span class="hljs-params">(b.ll()</span></span> == <span class="hljs-number">9999</span>)
</code></pre>
<h4 id="6-1-2-the-java-approach">6.1.2 The Java Approach</h4>
<p>BigInteger &amp; BigDecimal</p>
<h3 id="6-2-matrix">6.2 Matrix</h3>
<pre><code class="lang-C++"><span class="hljs-keyword">operator</span>+
<span class="hljs-keyword">operator</span>*
</code></pre>
<blockquote>
<p>Square matrix</p>
</blockquote>
<pre><code class="lang-C++">
<span class="hljs-keyword">struct</span> Matrix {
    <span class="hljs-comment">// int height;</span>
    <span class="hljs-comment">// int width;</span>

    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> value[<span class="hljs-number">32</span>][<span class="hljs-number">32</span>];

    Matrix <span class="hljs-keyword">operator</span>* (<span class="hljs-keyword">const</span> Matrix&amp; that);
    Matrix <span class="hljs-keyword">operator</span>+ (<span class="hljs-keyword">const</span> Matrix&amp; that);
    <span class="hljs-function">Matrix <span class="hljs-title">mirror</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;value[i][j] &lt;&lt; <span class="hljs-string">" "</span>;
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        }
    }
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mod_it</span><span class="hljs-params">(Matrix&amp; temp)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)
            temp.value[i][j] %= m;
}

Matrix Matrix::<span class="hljs-keyword">operator</span>* (<span class="hljs-keyword">const</span> Matrix&amp; that) {
    Matrix temp;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {
            temp.value[i][j] = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++)
                temp.value[i][j] += <span class="hljs-keyword">this</span>-&gt;value[i][k] * that.value[k][j];
        }
    }
    mod_it(temp);
    <span class="hljs-keyword">return</span> temp;
}

Matrix Matrix::<span class="hljs-keyword">operator</span>+ (<span class="hljs-keyword">const</span> Matrix&amp; that) {
    Matrix temp;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)
            temp.value[i][j] = <span class="hljs-keyword">this</span>-&gt;value[i][j] + that.value[i][j];
    mod_it(temp);
    <span class="hljs-keyword">return</span> temp;
}

Matrix Matrix::mirror() {
    Matrix temp;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)
            temp.value[i][j] = <span class="hljs-keyword">this</span>-&gt;value[i][j];
    <span class="hljs-keyword">return</span> temp;
}
</code></pre>
<h3 id="6-3-number-theory">6.3 Number Theory</h3>
<h4 id="6-3-1-">6.3.1 欧拉函数 ?</h4>
<h4 id="6-3-2-gcd">6.3.2 欧几里得算法 / gcd</h4>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a / gcd(a, b) * b;
}
</code></pre>
<h4 id="6-3-3-">6.3.3 扩展欧几里得算法</h4>
<p><code>http://www.cnblogs.com/frog112111/archive/2012/08/19/2646012.html</code></p>
<blockquote>
<p>对于不完全为 0 的非负整数 a, b, 必然存在整数对 (x, y), 使得 gcd(a, b) = ax + by</p>
<p>suppose: a &gt; b, we want to get (x1, y1)</p>
<p>(i) if b == 0, then gcd(a, b) = a = ax + 0, then x1 = 1, y1 = 0</p>
<p>(ii) if b != 0:</p>
<p>  (1): a <em> x1 + b </em> y1 = gcd(a, b)</p>
<p>  (2): b <em> x2 + (a % b) </em> y2 = gcd(b, a % b)</p>
<p>  (1) == (2)</p>
<p>  so: a <em> x1 + b </em> y1 = b <em> x2 + (a % b) </em> y2</p>
<p>  so: a <em> x1 + b </em> y1 = b <em> x2 + (a - (int)(a / b) </em> b) * y2</p>
<p>  so: a <em> x1 + b </em> y1 = a <em> y2 + b </em> (x2 - (int)(a / b) * y2)</p>
<p>  so: x1 = y2, y1 = x2 - (int)(a / b) * y2, can get (x1, y1) from (x2, y2)</p>
<p>  next:</p>
<pre><code>  (<span class="hljs-number">1</span>): <span class="hljs-keyword">b </span>* x2 + (a % <span class="hljs-keyword">b) </span>* y2 = gcd(<span class="hljs-keyword">b, </span>a % <span class="hljs-keyword">b)
</span>
  (<span class="hljs-number">2</span>): (a % <span class="hljs-keyword">b) </span>* x3 + <span class="hljs-keyword">b </span>% (a % <span class="hljs-keyword">b) </span>* y3 = gcd(a % <span class="hljs-keyword">b, </span><span class="hljs-keyword">b </span>% (a % <span class="hljs-keyword">b))
</span><span class="hljs-symbol">
  so:</span> can <span class="hljs-meta">get</span> (x2, y2) from (x3, y3)
<span class="hljs-symbol">
  next:</span> ... until in gcd(a, <span class="hljs-keyword">b), </span><span class="hljs-keyword">b </span>== <span class="hljs-number">0</span>, then xi = <span class="hljs-number">1</span>, yi = <span class="hljs-number">0</span>, go <span class="hljs-keyword">back </span>...
</code></pre></blockquote>
<pre><code class="lang-C++"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ansx, ansy, ansd;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">euclidean</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b)</span> </span>{
    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) {
        ansx = <span class="hljs-number">1</span>;
        ansy = <span class="hljs-number">0</span>;
        ansd = a;
    } <span class="hljs-keyword">else</span> {
        euclidean(b, a % b);
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = ansx;
        ansx = ansy;
        ansy = temp - a / b * ansy;
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>{
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, b, c;
    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;

    ansx = <span class="hljs-number">0</span>;
    ansy = <span class="hljs-number">0</span>;
    ansd = <span class="hljs-number">0</span>;
    euclidean(a, b);

    <span class="hljs-comment">// now (ansx, ansy) is the answer (x, y) for a * x1 + b * y1 = gcd(a, b)</span>
    <span class="hljs-comment">// ansd is the a when b == 0, which is just gcd(a, b)</span>
}
</code></pre>
<h4 id="6-3-4-">6.3.4 求解不定方程</h4>
<blockquote>
<p>for: p <em> a + q </em> b = c</p>
<p>if c % gcd(a, b) == 0, then 有整数解 (p, q), else NO</p>
<p>if we get (p0, q0) for p0 <em> a + q0 </em> b = gcd(a, b)</p>
<p>then: for p <em> a + q </em> b = gcd(a, b) (k is any integer)</p>
<p>p = p0 + b / gcd(a, b) * k</p>
<p>q = q0 - a / gcd(a, b) * k</p>
<p>then: for p <em> a + q </em> b = c = c / gcd(a, b) * gcd(a, b) (k is any integer)</p>
<p>p = (p0 + b / gcd(a, b) <em> k) </em> c / gcd(a, b)</p>
<p>q = (q0 - a / gcd(a, b) <em> k) </em> c / gcd(a, b)</p>
</blockquote>
<pre><code class="lang-C++">// <span class="hljs-keyword">after</span> <span class="hljs-built_in">get</span> ansx, ansy, ansd<span class="hljs-comment">
// test if c % ansd == 0</span><span class="hljs-comment">
// ansx = (ansx + b / gcd(a, b) * k) * c / gcd(a, b)</span><span class="hljs-comment">
// ansy = (ansy - a / gcd(a, b) * k) * c / gcd(a, b)</span><span class="hljs-comment">
// smallest: ansx % (b / gcd(a, b) + b / gcd(a, b)) % (b / gcd(a, b))</span>
</code></pre>
<h4 id="6-3-5-">6.3.5 求解模线性方程（线性同余方程）</h4>
<blockquote>
<p>(a * x) % n = b % n, x = ?</p>
<p>same as: a <em> x + n </em> y= b</p>
<p>so: one answer for a <em> x + n </em> y= b is: x * b / gcd(a, n)</p>
<p>so: one answer for (a <em> x) % n = b % n is: x0 = (x </em> b / gcd(a, n)) % n</p>
<p>other answer xi = (x0 + i * (n / gcd(a, n))) % n, i = 0...gcd(a, n)-1</p>
<p>smallest answer is x0 % (n / gcd(a, n) + gcd(a, n)) % gcd(a, n)</p>
</blockquote>
<pre><code class="lang-C++">
</code></pre>
<h4 id="6-3-6-">6.3.6 求解模的逆元</h4>
<blockquote>
<p>(a * x) % n = 1, x = ?</p>
<p>if gcd(a, n) != 1, then NO answer</p>
<p>else:</p>
<p>same as: a <em> x + n </em> y = 1</p>
<p>can get only one answer x</p>
</blockquote>
<pre><code class="lang-C++">// after get ansx, ansy, ansd
// <span class="hljs-built_in">if</span> ansd != <span class="hljs-number">1</span>, then NO answer
// smallest ansx = (ansx % (<span class="hljs-built_in">n</span> / <span class="hljs-built_in">gcd</span>(a, <span class="hljs-built_in">n</span>)) + (<span class="hljs-built_in">n</span> / <span class="hljs-built_in">gcd</span>(a, <span class="hljs-built_in">n</span>))) % (<span class="hljs-built_in">n</span> / <span class="hljs-built_in">gcd</span>(a, <span class="hljs-built_in">n</span>))
</code></pre>
<h4 id="6-3-7-">6.3.7 中国剩余定理</h4>
<h4 id="6-3-8-">6.3.8 最小公倍数</h4>
<pre><code class="lang-C++">a / gcd<span class="hljs-comment">(a, b)</span> * b
</code></pre>
<h4 id="6-3-9-">6.3.9 分解质因数</h4>
<pre><code class="lang-C++"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x;
<span class="hljs-built_in">cin</span> &gt;&gt; x;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> factor = <span class="hljs-number">2</span>; x != <span class="hljs-number">1</span>; factor++) {
    <span class="hljs-keyword">if</span> (x % factor == <span class="hljs-number">0</span>)
        <span class="hljs-built_in">cout</span> &lt;&lt; factor &lt;&lt; <span class="hljs-string">" is a prime factor"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">while</span> (x % factor == <span class="hljs-number">0</span>)
        x = x / factor;
}
</code></pre>
<h4 id="6-3-10-">6.3.10 因数个数</h4>
<pre><code class="lang-C++"><span class="hljs-attr">n</span> = p1 ^ x1 * p2 ^ x2 * ... * pn ^ xn
<span class="hljs-attr">total</span> = (x1 + <span class="hljs-number">1</span>) * (x2 + <span class="hljs-number">1</span>) * ... * (xn + <span class="hljs-number">1</span>)
</code></pre>
<h4 id="6-3-11-">6.3.11 素数判定</h4>
<blockquote>
<p>大于 3 的质数可以被表示为 6n - 1 或 6n + 1</p>
</blockquote>
<pre><code class="lang-C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  
    <span class="hljs-keyword">int</span> t = <span class="hljs-built_in">sqrt</span>(n);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= t; i += <span class="hljs-number">2</span>)
        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<h5 id="6-3-11-1-miller-rabin-primality-test">6.3.11.1 Miller Rabin Primality Test</h5>
<blockquote>
<p>O(k(logN)^3)</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-keyword">class</span> MillerRabin { <span class="hljs-comment">// O(k(logX)^3)</span>
    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">mulmod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span> </span>{
        <span class="hljs-keyword">if</span> (a &lt; b)
            swap(a, b);
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>, x = a;
        <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) {
                res = res + x;
                <span class="hljs-keyword">if</span> (res &gt;= c)
                    res -= c;
            }
            x = x * <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (x &gt;= c)
                x -= c;
            b &gt;&gt;= <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">return</span> res % c;
    }

    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">bigmod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mod)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x = a, res = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (p) {
            <span class="hljs-keyword">if</span> (p &amp; <span class="hljs-number">1</span>)
                res = mulmod(res, x, mod);
            x = mulmod(x, x, mod);
            p &gt;&gt;= <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">return</span> res;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">witness</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> s, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> r = bigmod(a, d, n);
        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">1</span> || r == n - <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s - <span class="hljs-number">1</span>; i++) {
            r = mulmod(r, r, n);
            <span class="hljs-keyword">if</span> (r == <span class="hljs-number">1</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (r == n - <span class="hljs-number">1</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; aaa{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>, <span class="hljs-number">31</span>, <span class="hljs-number">37</span>}; <span class="hljs-comment">// enough for N &lt; 2^64</span>

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p = n - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> s = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (!(p &amp; <span class="hljs-number">1</span>)) {
            p /= <span class="hljs-number">2</span>;
            s++;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; aaa.size() &amp;&amp; aaa[i] &lt; n; i++)
            <span class="hljs-keyword">if</span> (witness(aaa[i], p, s, n))
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};
</code></pre>
<h4 id="6-3-12-">6.3.12 进制转换</h4>
<pre><code class="lang-C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">convert_dec_to_base</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> base)</span> </span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">int</span> e = n % base;
        <span class="hljs-built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// printing in reverse order</span>
        n /= base;
    } <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">convert_base_to_dec</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> base)</span> </span>{
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        result = result * base + s[i];
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<h4 id="6-3-13-a-c">6.3.13 A / C</h4>
<blockquote>
<p>C(n, k) = C(n-1, k) + C(n-1, k-1)</p>
<p>C(n, k) = C(n, n-k)</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-section">#define MAXN 1002</span>
<span class="hljs-section">#define MOD 1000000007</span>
long long choose[<span class="hljs-string">MAXN</span>][<span class="hljs-symbol">MAXN</span>];

void init<span class="hljs-emphasis">_choose_</span>n_k() {
<span class="hljs-code">    for (int i = 1; i &lt; MAXN; i++) {</span>
<span class="hljs-code">        choose[i][i] = choose[i][0] = 1;</span>
<span class="hljs-code">        for (int j = 1; j &lt; i; j++)</span>
<span class="hljs-code">            choose[i][j] = (choose[i-1][j-1] + choose[i-1][j]) % MOD;</span>
<span class="hljs-code">    }</span>
}
</code></pre>
<h4 id="6-3-14-">6.3.14 质数表</h4>
<pre><code class="lang-C++"><span class="hljs-built_in">int</span> is_prime[<span class="hljs-type">UP_LIMIT</span> + <span class="hljs-number">1</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-type">UP_LIMIT</span>; i++) // init to <span class="hljs-number">1</span>
    is_prime[i] = <span class="hljs-number">1</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">4</span>; i &lt;= <span class="hljs-type">UP_LIMIT</span>; i += <span class="hljs-number">2</span>) // even number <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span>
    is_prime[i] = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">3</span>; k*k &lt;= <span class="hljs-type">UP_LIMIT</span>; k++) // start <span class="hljs-keyword">from</span> <span class="hljs-number">9</span>, <span class="hljs-keyword">end</span> at sqrt
    <span class="hljs-keyword">if</span> (is_prime[k])
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = k*k; i &lt;= <span class="hljs-type">UP_LIMIT</span>; i += <span class="hljs-number">2</span>*k) // every two <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> 
            is_prime[i] = <span class="hljs-number">0</span>;
</code></pre>
<h4 id="6-3-15-fast-exponention">6.3.15 Fast Exponention</h4>
<blockquote>
<p>To calculate n ^ p % M</p>
</blockquote>
<pre><code class="lang-C++"><span class="hljs-built_in">int</span> power_modulo(<span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> p, <span class="hljs-built_in">int</span> M) {
    <span class="hljs-built_in">int</span> <span class="hljs-literal">result</span> = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (p &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (p % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)
            <span class="hljs-literal">result</span> = (<span class="hljs-literal">result</span>*n) % M;
        p /= <span class="hljs-number">2</span>;
        n = (n*n) % M;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">result</span>;
}
</code></pre>
<h4 id="6-3-16-fast-fourier-transform-fft">6.3.16 Fast Fourier Transform FFT</h4>
<blockquote>
<p><a href="www.gatevin.moe/acm/fft算法学习笔记/">Reference 1</a></p>
<p><a href="https://github.com/marioyc/ACM-ICPC-Library/blob/master/math/fft.cpp">Reference 2</a></p>
<p>Example: calculate two number C = A * B</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;complex&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> M_PI</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> M_PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">complex</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>&gt; Complex;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;Complex&gt; &amp;A, <span class="hljs-keyword">int</span> s)</span> </span>{
    <span class="hljs-keyword">int</span> n = A.size();
    <span class="hljs-keyword">int</span> p = __builtin_ctz(n);

    <span class="hljs-built_in">vector</span>&lt;Complex&gt; a = A;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
        <span class="hljs-keyword">int</span> rev = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; p; ++j) {
            rev &lt;&lt;= <span class="hljs-number">1</span>;
            rev |= ((i &gt;&gt; j) &amp; <span class="hljs-number">1</span>);
        }
        A[i] = a[rev];
    }

    Complex w, wn;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; ++i) {
        <span class="hljs-keyword">int</span> M = (<span class="hljs-number">1</span>&lt;&lt;i), K = (M&gt;&gt;<span class="hljs-number">1</span>);
        wn = Complex(<span class="hljs-built_in">cos</span>(s*<span class="hljs-number">2.0</span>*M_PI/(<span class="hljs-keyword">double</span>)M), <span class="hljs-built_in">sin</span>(s*<span class="hljs-number">2.0</span>*M_PI/(<span class="hljs-keyword">double</span>)M));

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j += M) {
            w = Complex(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = j; l &lt; K + j; ++l) {
                Complex t = w;
                t *= A[l + K];
                Complex u = A[l];
                A[l] += t;
                u -= t;
                A[l + K] = u;
                w *= wn;
            }
        }
    }

    <span class="hljs-keyword">if</span> (s == <span class="hljs-number">-1</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
            A[i] /= (<span class="hljs-keyword">double</span>)n;
    }
}

<span class="hljs-built_in">vector</span>&lt;Complex&gt; FFT_Multiply(<span class="hljs-built_in">vector</span>&lt;Complex&gt; &amp;P, <span class="hljs-built_in">vector</span>&lt;Complex&gt; &amp;Q) {
    <span class="hljs-keyword">int</span> n = P.size() + Q.size();

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lowbit(x) (((x) ^ (x-1)) &amp; (x))</span>
    <span class="hljs-keyword">while</span> (n != lowbit(n)) n += lowbit(n);
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> lowbit</span>

    P.resize(n, <span class="hljs-number">0</span>);
    Q.resize(n, <span class="hljs-number">0</span>);

    FFT(P, <span class="hljs-number">1</span>);
    FFT(Q, <span class="hljs-number">1</span>);

    <span class="hljs-built_in">vector</span>&lt;Complex&gt; R;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) R.push_back(P[i] * Q[i]);

    FFT(R, <span class="hljs-number">-1</span>);

    <span class="hljs-keyword">return</span> R;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// multiply two number </span>
    <span class="hljs-built_in">string</span> sa; <span class="hljs-comment">// [a1 * 10^(?)] + [a2 * 10^(?)] + ... + [an * 10^(?)]</span>
    <span class="hljs-built_in">string</span> sb; <span class="hljs-comment">// [b1 * 10^(?)] + [b2 * 10^(?)] + ... + [bm * 10^(?)]</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; sa &gt;&gt; sb) {
        <span class="hljs-built_in">vector</span>&lt;Complex&gt; a;
        <span class="hljs-built_in">vector</span>&lt;Complex&gt; b;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sa.length(); i++)
            a.push_back(Complex(sa[sa.length() - i - <span class="hljs-number">1</span>] - <span class="hljs-string">'0'</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// add [a_ * (x)^(?)]</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sb.length(); i++)
            b.push_back(Complex(sb[sb.length() - i - <span class="hljs-number">1</span>] - <span class="hljs-string">'0'</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// add [b_ * (x)^(?)]</span>

         <span class="hljs-comment">// [c1 * 10^(?)] + [c2 * 10^(?)] + ... + [cn * 10^(?)]</span>
         <span class="hljs-comment">// =</span>
         <span class="hljs-comment">// [a1 * 10^(?)] + [a2 * 10^(?)] + ... + [an * 10^(?)]</span>
         <span class="hljs-comment">// *</span>
         <span class="hljs-comment">// [b1 * 10^(?)] + [b2 * 10^(?)] + ... + [bm * 10^(?)]</span>
        <span class="hljs-built_in">vector</span>&lt;Complex&gt; c = FFT_Multiply(a, b);

        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans(c.size());
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.size(); i++)
            ans[i] = c[i].real() + <span class="hljs-number">0.5</span>; <span class="hljs-comment">// extract [c_ * (x)^(?)] // equivalent to [c_ * (x=10)^(?)]</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size() - <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// process carry</span>
            ans[i + <span class="hljs-number">1</span>] += ans[i] / <span class="hljs-number">10</span>;
            ans[i] %= <span class="hljs-number">10</span>;
        }

        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = ans.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) { <span class="hljs-comment">// print from most significant digit</span>
            <span class="hljs-keyword">if</span> (ans[i])
                <span class="hljs-built_in">cout</span> &lt;&lt; ans[i], flag = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag || i == <span class="hljs-number">0</span>)
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">0</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}
</code></pre>
<h3 id="6-4-game-theory-">6.4 Game Theory 博弈论</h3>
<h4 id="6-4-1-impartial-combinatorial-game">6.4.1 Impartial Combinatorial Game</h4>
<blockquote>
<p>In combinatorial game theory, an impartial game is a game in which the allowable moves depend only on the position and not on which of the two players is currently moving, and where the payoffs are symmetric. In other words, the only difference between player 1 and player 2 is that player 1 goes first.</p>
<p>Impartial games can be analyzed using the Sprague–Grundy theorem.</p>
<p>Impartial games include Nim, Sprouts, Kayles, Quarto, Cram, Chomp, and poset games. Go and chess are not impartial, as each player can only place or move pieces of their own color. Games like ZÈRTZ and Chameleon are also not impartial, since although they are played with shared pieces, the payoffs are not necessarily symmetric for any given position.</p>
<p>A game that is not impartial is called a partisan game.</p>
<p><a href="https://en.wikipedia.org/wiki/Impartial_game">source: wiki</a></p>
<p><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/algorithm-games/">tutorial: topcoder</a></p>
</blockquote>
<h5 id="6-4-1-1-nim-game">6.4.1.1 Nim Game</h5>
<blockquote>
<p>One good choice: brute force to find some pattern.</p>
<p>We will not be able to play many of the games without decomposing them to smaller parts (sub-games), pre-computing some values for them, and then obtaining the result by combining these values.</p>
<p>Positions have the following properties:</p>
<ul>
<li>All terminal positions are losing.</li>
<li>If a player is able to move to a losing position then he is in a winning position.</li>
<li>If a player is able to move only to the winning positions then he is in a losing position.</li>
</ul>
<p>Rules of the Game of Nim: There are n piles of coins. When it is a player’s turn he chooses one pile and takes at least one coin from it. If someone is unable to move he loses (so the one who removes the last coin is the winner).</p>
<p>Let n1, n2, ..., nk, be the sizes of the piles. It is a losing position for the player whose turn it is if and only if n1 xor n2 xor ... xor nk = 0.</p>
</blockquote>
<h5 id="6-4-1-1-composite-games-sprague-grundy-theorem-and-nim-value">6.4.1.1 Composite Games – Sprague-Grundy Theorem and Nim Value</h5>
<blockquote>
<ul>
<li>Break composite game into subgames</li>
<li>Assign grundy number to every subgame according to which size of the pile in the Game of Nim it is equivalent to.</li>
<li>Now we have some subgames (piles), each subgame has its grundy number (size of pile)</li>
<li><p>xor all subgames</p>
</li>
<li><p>Losing position of subgame has grundy number = 0.</p>
</li>
<li>A position has grundy number = smallest number among its next positions don&#39;t have.</li>
</ul>
<p>If the table of grundy number is too large, we can precompute and find the pattern.</p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-comment">// hihocoer 1173</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXSTATE = <span class="hljs-number">2e4</span> + <span class="hljs-number">2</span>;

<span class="hljs-keyword">bool</span> appear[MAXSTATE];
<span class="hljs-keyword">int</span> sg[MAXSTATE]; <span class="hljs-comment">// Sprague-Grundy // Nim Value</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_sg</span><span class="hljs-params">()</span> </span>{
    sg[state] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> state = <span class="hljs-number">1</span>; state &lt; MAXSTATE; state++) { <span class="hljs-comment">// sg(x) = mex{sg(y) | y是x的后继局面} // mex{a[i]}表示a中未出现的最小非负整数</span>
        fill_n(appear, MAXSTATE, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> nx = <span class="hljs-number">0</span>; nx &lt; state; nx++)
            appear[sg[nx]] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">int</span> pile_a = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> pile_b = state - pile_a;
        <span class="hljs-keyword">while</span> (pile_a &lt;= pile_b) {
            appear[sg[pile_a] ^ sg[pile_b]] = <span class="hljs-literal">true</span>;
            pile_a++;
            pile_b--;
        }
        <span class="hljs-keyword">while</span> (appear[sg[state]])
            sg[state]++;
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{

    init_sg();

    <span class="hljs-comment">// --- start of finding pattern ---</span>
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// --- end of finding pattern ---</span>

    <span class="hljs-keyword">int</span> n;
    <span class="hljs-built_in">cin</span> &gt;&gt; n;
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> a;
        <span class="hljs-built_in">cin</span> &gt;&gt; a;

        <span class="hljs-comment">// by grundy number </span>
        <span class="hljs-comment">// result ^= sg[a];</span>

        <span class="hljs-comment">// by pattern</span>
        <span class="hljs-comment">// if (a % 4 == 0)</span>
        <span class="hljs-comment">//     a--;</span>
        <span class="hljs-comment">// else if (a % 4 == 3)</span>
        <span class="hljs-comment">//     a++;</span>
        <span class="hljs-comment">// result ^= a; </span>
    }
    <span class="hljs-keyword">if</span> (result)
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Alice"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Bob"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="7-geometry">7. Geometry</h2>
<h3 id="7-1-2-dimension-space">7.1 2-Dimension Space</h3>
<h4 id="7-1-1-template-of-point">7.1.1 Template of Point</h4>
<pre><code class="lang-C++"><span class="hljs-keyword">struct</span> <span class="hljs-built_in">point</span> {
    <span class="hljs-keyword">int</span> x, y;

    <span class="hljs-keyword">double</span> length() {
        <span class="hljs-built_in">return</span> <span class="hljs-built_in">sqrt</span>(x*x + y*y);
    }

    <span class="hljs-built_in">point</span> <span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span> &amp;rhs) <span class="hljs-keyword">const</span> {
        <span class="hljs-built_in">return</span> (<span class="hljs-built_in">point</span>){x + rhs.x, y + rhs.y};
    }

    <span class="hljs-built_in">point</span> <span class="hljs-keyword">operator</span> - (<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span> &amp;rhs) <span class="hljs-keyword">const</span> {
        <span class="hljs-built_in">return</span> (<span class="hljs-built_in">point</span>){x - rhs.x, y - rhs.y};
    }

    <span class="hljs-keyword">long</span> <span class="hljs-keyword">operator</span>* (<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; b) {
        <span class="hljs-built_in">return</span> x*b.y - y*b.x;
    }

    <span class="hljs-keyword">long</span> cross_product(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; b) {
      <span class="hljs-built_in">return</span> x * b.x + y * b.y;
    }

    <span class="hljs-keyword">bool</span> at_right_of(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-comment">// a: relative point, b: base</span>
        <span class="hljs-built_in">point</span> vec_self = {x - b.x, y - b.y};
        <span class="hljs-built_in">point</span> vec_that = {a.x - b.x, a.y - b.y};
        <span class="hljs-keyword">long</span> product = vec_self * vec_that;
        <span class="hljs-built_in">if</span> (product&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">return</span> true;
        <span class="hljs-built_in">if</span> (product==<span class="hljs-number">0</span> &amp;&amp; vec_self.length()&gt;vec_that.length()) <span class="hljs-built_in">return</span> true;
        <span class="hljs-built_in">return</span> false;
    }

    <span class="hljs-keyword">double</span> to_point(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-built_in">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(x-b.x,<span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(y-b.y,<span class="hljs-number">2</span>));
    }

    <span class="hljs-keyword">double</span> to_segment(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">double</span> len_ab = a.to_point(b);
        <span class="hljs-built_in">if</span> (<span class="hljs-built_in">abs</span>(len_ab)&lt;E) <span class="hljs-built_in">return</span> to_point(a);
        <span class="hljs-keyword">double</span> r = ((a.y-y)*(a.y-b.y) - (a.x-x)*(a.x-b.x))/<span class="hljs-built_in">pow</span>(len_ab,<span class="hljs-number">2</span>);
        <span class="hljs-built_in">if</span> (r&gt;<span class="hljs-number">1</span> || r&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">return</span> <span class="hljs-built_in">min</span>(to_point(a), to_point(b));
        <span class="hljs-comment">// projection of p is on extension of AB</span>
        r = ((a.y - y)*(b.y - y) - (a.x - x)*(b.y - a.y))/<span class="hljs-built_in">pow</span>(len_ab,<span class="hljs-number">2</span>);
        <span class="hljs-built_in">return</span> fabs(r*len_ab);
    }

    <span class="hljs-keyword">double</span> to_segment(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-built_in">point</span> vec_ab = {b.x - a.x, b.y - a.y};
        <span class="hljs-built_in">point</span> vec_ia = {x - a.x, y - a.y};
        <span class="hljs-built_in">point</span> vec_ib = {x - b.x, y - b.y};
        <span class="hljs-built_in">if</span> (vec_ia.cross_product(vec_ab) &lt; <span class="hljs-number">0</span> || vec_ib.cross_product(vec_ab) &gt; <span class="hljs-number">0</span>)
            <span class="hljs-built_in">return</span> <span class="hljs-built_in">min</span>(to_point(a), to_point(b));
        <span class="hljs-built_in">return</span> <span class="hljs-built_in">abs</span>(vec_ab * vec_ia) / vec_ab.length();
    } <span class="hljs-comment">// same meaning with v1, need test</span>

    <span class="hljs-keyword">double</span> to_line(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span>&amp; b) <span class="hljs-keyword">const</span> {
        <span class="hljs-built_in">point</span> vec_ab = {b.x - a.x, b.y - a.y};
        <span class="hljs-built_in">point</span> vec_ia = {x - a.x, y - a.y};
        <span class="hljs-built_in">return</span> <span class="hljs-built_in">abs</span>(vec_ab * vec_ia) / vec_ab.length();
    } <span class="hljs-comment">// same meaning with v1, need test</span>

    <span class="hljs-built_in">point</span> rotate(<span class="hljs-keyword">const</span> <span class="hljs-built_in">point</span> &amp;rhs, <span class="hljs-keyword">double</span> angle) <span class="hljs-keyword">const</span> {
        <span class="hljs-built_in">point</span> t = (*<span class="hljs-keyword">this</span>) - rhs;
        <span class="hljs-keyword">double</span> c = <span class="hljs-built_in">cos</span>(angle), s = <span class="hljs-built_in">sin</span>(angle);
        <span class="hljs-built_in">return</span> (<span class="hljs-built_in">point</span>){rhs.x + t.x * c - t.y * s, rhs.y + t.x * s + t.y * c};
    }
};
</code></pre>
<h4 id="7-1-2-">7.1.2 向量点乘 叉乘</h4>
<blockquote>
<p>a = (x1, y1)</p>
<p>b = (x2, y2)</p>
<p>i ... |i| = 1, vertical to a-b surface</p>
</blockquote>
<h4 id="7-1-3-dot-product">7.1.3 dot product</h4>
<blockquote>
<p>a dot b = x1 <em> x2 + y1 </em> y2 = |a| <em> |b| </em> cos(angle)</p>
<p>if = 0: 90 degree</p>
<p>a dot b / |b| = a project to b</p>
</blockquote>
<h4 id="7-1-4-cross-product">7.1.4 cross product</h4>
<blockquote>
<p>a x b = x1 <em> y2 - x2 </em> y1 = |a| <em> |b| </em> sin(angle) * i</p>
<p>if &lt; 0: b is at left of a</p>
<p>if = 0: a, b in a line</p>
<p>if 0: b is at right of a</p>
<p>a x b = area of 平行四边形</p>
<p>a x b x c = area of 平行六面体, c = (x3, y3)</p>
</blockquote>
<h4 id="7-1-5-">7.1.5 直线公式</h4>
<blockquote>
<p>(x, y) = (x1, y1) + k * ((x2, y2) - (x1, y1))</p>
</blockquote>
<h4 id="7-1-6-convex-hull">7.1.6 Convex Hull</h4>
<h5 id="gift-wrapping">Gift Wrapping</h5>
<blockquote>
<p>place holder</p>
</blockquote>
<h5 id="quickhull">QuickHull</h5>
<blockquote>
<p>place holder</p>
</blockquote>
<h5 id="graham-scan">Graham scan</h5>
<blockquote>
<p>O(VlogV)</p>
</blockquote>
<pre><code class="lang-C++"><span class="hljs-keyword">struct</span> Point {
    <span class="hljs-keyword">long</span> x;
    <span class="hljs-keyword">long</span> y;

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">at_right_of</span><span class="hljs-params">(Point&amp; that, Point&amp; base)</span> </span>{
        Point vec_self = {<span class="hljs-keyword">this</span>-&gt;x - base.x, <span class="hljs-keyword">this</span>-&gt;y - base.y};
        Point vec_that = {that.x - base.x, that.y - base.y};

        <span class="hljs-keyword">long</span> product = vec_self * vec_that;
        <span class="hljs-keyword">if</span> (product &gt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// "this" is at right of "that"</span>
        <span class="hljs-keyword">if</span> (product == <span class="hljs-number">0</span> &amp;&amp; vec_self.length() &gt; vec_that.length())
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// "this" is at right of "that"</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// "this" is NOT at right of "that"</span>
    };
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">operator</span>* (Point&amp; that) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;x * that.y - <span class="hljs-keyword">this</span>-&gt;y * that.x;
    };
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">distance_to</span><span class="hljs-params">(Point&amp; that)</span> </span>{
        <span class="hljs-keyword">long</span> x_diff = <span class="hljs-keyword">this</span>-&gt;x - that.x;
        <span class="hljs-keyword">long</span> y_diff = <span class="hljs-keyword">this</span>-&gt;y - that.y;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(x_diff * x_diff + y_diff * y_diff);
    };
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-keyword">this</span>-&gt;x * <span class="hljs-keyword">this</span>-&gt;x + <span class="hljs-keyword">this</span>-&gt;y * <span class="hljs-keyword">this</span>-&gt;y);
    }
};

Point p[<span class="hljs-number">1005</span>];
<span class="hljs-keyword">int</span> my_stack[<span class="hljs-number">1005</span>];
<span class="hljs-keyword">int</span> n, l, my_stack_top = <span class="hljs-number">-1</span>;

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(Point p1, Point p2)</span> </span>{
    <span class="hljs-keyword">return</span> p1.at_right_of(p2, p[<span class="hljs-number">0</span>]);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
    my_stack[++my_stack_top] = index;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> temp = my_stack[my_stack_top--];
    <span class="hljs-keyword">return</span> temp;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">graham_scan</span><span class="hljs-params">()</span> </span>{
    push(<span class="hljs-number">0</span>);
    push(<span class="hljs-number">1</span>);

    <span class="hljs-keyword">int</span> pre;
    <span class="hljs-keyword">int</span> prepre;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) {
        pre = my_stack_top;
        prepre = my_stack_top - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (p[i].at_right_of(p[my_stack[pre]], p[my_stack[prepre]])) {
            pop();
            <span class="hljs-keyword">if</span> (my_stack_top == <span class="hljs-number">0</span>)
                <span class="hljs-keyword">break</span>;
            pre = my_stack_top;
            prepre = my_stack_top - <span class="hljs-number">1</span>;
        }
        push(i);
    }

    <span class="hljs-keyword">int</span> last = my_stack_top;
    <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>].at_right_of(p[my_stack[last]], p[my_stack[pre]]))
        pop();
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span> </span>{
    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; l;

    <span class="hljs-keyword">int</span> minimun = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
        <span class="hljs-keyword">int</span> temp_x, temp_y;
        <span class="hljs-built_in">cin</span> &gt;&gt; temp_x &gt;&gt; temp_y;
        p[i] = {temp_x, temp_y};

        <span class="hljs-keyword">if</span> ((p[i].y &lt; p[minimun].y) || (p[i].y == p[minimun].y &amp;&amp; p[i].x &lt; p[minimun].x))
            minimun = i;
    }

    Point temp = {p[minimun].x, p[minimun].y}; <span class="hljs-comment">// swap lowest and most left point to p[0]</span>
    p[minimun] = p[<span class="hljs-number">0</span>];
    p[<span class="hljs-number">0</span>] = temp;

    sort(p + <span class="hljs-number">1</span>, p + n, compare); <span class="hljs-comment">// use p[0] as base, sort according to polar angle</span>
    graham_scan();
    <span class="hljs-comment">// now all points in the stack is on Convex Hull // size of stack = 1 + stack_top</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= my_stack_top; i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"point "</span> &lt;&lt; my_stack[i] &lt;&lt; <span class="hljs-string">" is on Convex Hull"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<h2 id="8-tricks-miscellaneous">8. Tricks + Miscellaneous</h2>
<h3 id="8-1-bit-manipulation">8.1 Bit Manipulation</h3>
<pre><code class="lang-c++">#define GET_BIT(<span class="hljs-name">n</span>, i) (((<span class="hljs-name">n</span>) &amp; (<span class="hljs-number">1</span>LL &lt;&lt; ((<span class="hljs-name">i</span>)<span class="hljs-number">-1</span>))) &gt;&gt; ((<span class="hljs-name">i</span>)<span class="hljs-number">-1</span>)) // i start from <span class="hljs-number">1</span>
#define SET_BIT(<span class="hljs-name">n</span>, i) ((<span class="hljs-name">n</span>) | (<span class="hljs-number">1</span>LL &lt;&lt; ((<span class="hljs-name">i</span>)<span class="hljs-number">-1</span>)))
#define CLR_BIT(<span class="hljs-name">n</span>, i) ((<span class="hljs-name">n</span>) &amp; ~(<span class="hljs-number">1</span>LL &lt;&lt; ((<span class="hljs-name">i</span>)<span class="hljs-number">-1</span>)))
</code></pre>
<h3 id="8-1-cantor-expansion-reverse-cantor-expansion">8.1 Cantor Expansion / Reverse Cantor Expansion</h3>
<blockquote>
<p>for hashing, or ...</p>
</blockquote>
<pre><code class="lang-C++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = n;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)
        ans = ans * i;
    <span class="hljs-keyword">return</span> ans;
}

<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">cantor_expansion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permutation[], <span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-comment">// input: (m-th permutation of n numbers, n)</span>
    <span class="hljs-comment">// return: m</span>
    <span class="hljs-keyword">int</span> used[n + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">memset</span>(used, n, <span class="hljs-keyword">sizeof</span>(used));

    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;
        used[permutation[i]] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; permutation[i]; j++)
            <span class="hljs-keyword">if</span> (used[j] != <span class="hljs-number">1</span>)
                temp += <span class="hljs-number">1</span>;
        ans += factorial(n - <span class="hljs-number">1</span> - i) * temp;
    }

    <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse_cantor_expansion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m)</span> </span>{
    <span class="hljs-comment">// m-th permutation of n numbers</span>
    <span class="hljs-keyword">int</span> ans[n + <span class="hljs-number">1</span>], used[n + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> (ans));
    <span class="hljs-built_in">memset</span>(used, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (used));

    m = m - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fac = factorial(i);
        <span class="hljs-keyword">int</span> temp = m / fac + <span class="hljs-number">1</span>;
        m = m - (temp - <span class="hljs-number">1</span>) * fac;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= temp; j++)
            <span class="hljs-keyword">if</span> (used[j] == <span class="hljs-number">1</span>)
                temp++;

        ans[n - i] = temp;
        used[temp] = <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n"</span>;
}
</code></pre>
<h3 id="8-2-pass-2-d-array">8.2 pass 2-D array</h3>
<pre><code class="lang-c++"><span class="hljs-comment">// The parameter is a 2D array</span>
<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">passFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[][<span class="hljs-number">10</span>])</span> </span>{
    <span class="hljs-comment">// ...</span>
}
passFunc(<span class="hljs-built_in">array</span>);

<span class="hljs-comment">// The parameter is an array containing pointers</span>
<span class="hljs-keyword">int</span> *<span class="hljs-built_in">array</span>[<span class="hljs-number">10</span>];
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
    <span class="hljs-built_in">array</span>[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">passFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a[<span class="hljs-number">10</span>])</span> </span>{
    <span class="hljs-comment">// ...</span>
}
passFunc(<span class="hljs-built_in">array</span>);

<span class="hljs-comment">// The parameter is a pointer to a pointer</span>
<span class="hljs-keyword">int</span> **<span class="hljs-built_in">array</span>;
<span class="hljs-built_in">array</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> *[<span class="hljs-number">10</span>];
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span>; i++)
    <span class="hljs-built_in">array</span>[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">passFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **a)</span> </span>{
    <span class="hljs-comment">// ...</span>
}
passFunc(<span class="hljs-built_in">array</span>);
</code></pre>
<h3 id="8-3-binary-display">8.3 Binary Display</h3>
<pre><code class="lang-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bitset&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_binary</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x)</span> </span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, <span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">64</span>&gt;(x).to_string().c_str());
}
</code></pre>
<h3 id="8-4-fast-log">8.4 Fast Log</h3>
<blockquote>
<p>Built-in <code>log(double)</code> is not accurate for integer.</p>
<p>Should <code>(int)(log(double)+0.000....001)</code></p>
</blockquote>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fastlog</span>(<span class="hljs-params">unsigned <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x, unsigned <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">base</span></span>) </span>{
    <span class="hljs-comment">// ERROR VALUE IF X == BASE == ULLONG_MAX</span>

    <span class="hljs-keyword">const</span> unsigned <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> HALF = <span class="hljs-number">1</span>ULL &lt;&lt; <span class="hljs-number">32</span>;
    unsigned <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cache[<span class="hljs-number">7</span>];
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INIT(i) { cache[i] = base; <span class="hljs-meta-keyword">if</span> (base &lt; HALF) base *= base; <span class="hljs-meta-keyword">else</span> base = ULLONG_MAX; }</span>
    INIT(<span class="hljs-number">0</span>); INIT(<span class="hljs-number">1</span>); INIT(<span class="hljs-number">2</span>); INIT(<span class="hljs-number">3</span>); INIT(<span class="hljs-number">4</span>); INIT(<span class="hljs-number">5</span>); INIT(<span class="hljs-number">6</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> INIT</span>

    <span class="hljs-keyword">int</span> ret = -(x == <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S(i, k) <span class="hljs-meta-keyword">if</span> (x &gt;= cache[i]) ret += k, x /= cache[i]; <span class="hljs-meta-keyword">else</span> return ret;</span>
    S(<span class="hljs-number">6</span>, <span class="hljs-number">64</span>); S(<span class="hljs-number">5</span>, <span class="hljs-number">32</span>); S(<span class="hljs-number">4</span>, <span class="hljs-number">16</span>); S(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>); S(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>); S(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); S(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); 
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> S</span>
}
</code></pre>
<h3 id="8-5-squre-root">8.5 Squre Root</h3>
<pre><code class="lang-c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sq</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a)</span> </span>{
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> l = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> r = a + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r) {
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m = (l + r) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (a / m &lt; m)
            r = m;
        <span class="hljs-keyword">else</span>
            l = m;
    }
    <span class="hljs-keyword">return</span> l;
}
</code></pre>
<p>AC I - Redemption 
AC II - Revenge 
AC: Brotherhood - Justice 
AC: Revelation - Answers 
AC III - Freedom 
AC IV - Glory 
AC Rogue - Betrayal 
AC Unity - Love 
AC Syndicate - Family 
AC Origins - Beginnings﻿</p>
<pre><code><span class="hljs-comment">"As you write your odyssey across the mountains and seas, remember: the fate of Greece journeys with you."</span> <span class="hljs-type">AC</span> <span class="hljs-type">Odyssey</span>
</code></pre></body></html>